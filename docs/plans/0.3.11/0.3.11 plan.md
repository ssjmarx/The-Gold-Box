# Implementation Plan: Patch 0.3.11 - The Observer

**Version:** 0.3.11  
**Branch:** `feature/0.3.11-the-observer`  
**Status:** ðŸš§ IN PLANNING  
**Goal:** Provide the AI with deep contextual awareness of the physical environment and the game's lore, giving it "eyes" and "ears" to understand the *where* and the *why*

---

## Overview

Patch 0.3.11 implements location-based spatial awareness and knowledge discovery tools as outlined in ROADMAP.md. This patch focuses on giving the AI the ability to understand the physical environment through a unified spatial filtering system, access game lore (journal entries, compendium), and track party composition. The implementation builds on the foundation established in 0.3.9 and combat features in 0.3.10.

### Key Deliverables

1. **Unified Spatial Filtering** - Single tool for location-based scene object queries with configurable units
2. **Journal Context Search** - Search within journal entries for specific information
3. **Compendium Search** - Search compendium packs for items, spells, monsters, etc.
4. **Party Member Tracking** - Get list of all player-controlled characters
5. **Enhanced Delta Tracking** - Track scene changes, token movements, and note updates
6. **Initial Context Expansion** - Auto-trigger spatial searches based on user's PC token
7. **User-Configurable Distance Units** - System-agnostic natural language distance reporting
8. **Distance Matrix for Nearest Tokens** - Pairwise distances between top 5 tokens
9. **Wall Shape Detection with Shapely** - Detect rectangles, squares, circles, polygons

---

## Feature 1: Unified Spatial Filtering System

**Priority:** High  
**Complexity:** High  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/services/spatial_services/scene_spatial_filter.py` (NEW service)
- `scripts/services/settings-manager.js` (new spatial settings)
- `scripts/gold-box.js` (settings UI)
- `backend/testing/function_check.sh` (test cases)
- `backend/requirements.txt` (add shapely dependency)

### Architecture

```
AI â†’ get_nearby_objects(origin, radius, search_mode) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                  â†“
Scene data (walls, doors, notes, lights, tokens) â†’ Backend processing
                                                                  â†“
Filtered objects with distances â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

**Core Concept:**
- **Minecraft-style "chunking"**: AI queries spatial area around origin point
- **Radius-based filtering**: Get objects within configurable radius
- **Two search modes**: Absolute (all objects) vs Line-of-Sight (visible only)
- **User-configurable units**: Plain language "5 feet", "2 meters", defaults to squares
- **Token distances included**: Pre-calculated distances to other tokens
- **Distance matrix for nearest 5**: Pairwise distances between closest tokens
- **No spatial summaries yet**: Test AI performance before adding complexity

### Tasks

1. **Implement `get_nearby_objects` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "get_nearby_objects",
             "description": "Get scene objects within a radius of a location or token. Use absolute mode for all objects in radius, or line-of-sight mode for only visible objects (respects vision-blocking walls). Distances are reported in user-configured units (default: 5 feet). Enables spatial awareness for room descriptions, trap detection, spell targeting, environmental understanding. Example: Search around a token you want to target with Fireball to determine which enemies are within spell range.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "origin": {
                         "oneOf": [
                             {
                                 "type": "object",
                                 "properties": {
                                     "x": {"type": "number"},
                                     "y": {"type": "number"}
                                 }
                             },
                             {"type": "string"}
                         ],
                         "description": "Search origin: absolute coordinates {x: 1000, y: 1500} or token_id (uses token center)"
                     },
                     "radius": {
                         "type": "number",
                         "description": "Search radius in grid units (default: 6 = 30ft in 5ft grids)",
                         "default": 6
                     },
                     "search_mode": {
                         "type": "string",
                         "enum": ["absolute", "line_of_sight"],
                         "description": "absolute: all objects in radius, line_of_sight: only visible objects (respects walls)",
                         "default": "line_of_sight"
                     }
                 },
                 "required": ["origin"]
             }
         }
     }
     ```

2. **Implement `get_nearby_objects` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_nearby_objects()` method
   - Validate input parameters (origin, radius, search_mode)
   - Send spatial filter request to frontend via WebSocket
   - Include origin, radius, and search_mode in request
   - Await spatial filter response (5 second timeout)
   - Format and return filtered objects with distances to AI
   - Handle timeout and error cases

3. **Create Scene Spatial Filter Service** (`backend/services/spatial_services/scene_spatial_filter.py`)
   - Create new service file: `scene_spatial_filter.py`
   - Implement `SceneSpatialFilter` class:
     ```python
     class SceneSpatialFilter:
         def __init__(self, grid_size, distance_unit_setting, max_nearest_tokens=5):
             self.grid_size = grid_size  # Foundry grid size (units per square)
             self.distance_unit = parse_distance_unit(distance_unit_setting)
             self.max_nearest_tokens = max_nearest_tokens
         
         def get_nearby_objects(self, scene_data, origin, radius, search_mode):
             # 1. Parse origin (coordinates or token center)
             origin_coords = self._parse_origin(origin, scene_data.get('tokens', []))
             
             # 2. Filter objects by radius (Euclidean distance)
             in_radius = self._filter_by_radius(scene_data, origin_coords, radius)
             
             # 3. If line-of-sight mode: filter by visibility
             if search_mode == "line_of_sight":
                 visible = self._filter_by_los(origin_coords, in_radius, scene_data.get('walls', []))
             else:
                 visible = in_radius
             
             # 4. Sort by distance and format output
             sorted_objects = self._sort_and_format(origin_coords, visible, self.grid_size, self.distance_unit)
             
             # 5. Structure output hierarchically
             return self._structure_output(sorted_objects, origin, radius, search_mode)
         
         def _parse_origin(self, origin, tokens):
             if isinstance(origin, str):  # token_id
                 token = next((t for t in tokens if t.get('id') == origin), None)
                 if token:
                     return {"x": token.get('x', 0), "y": token.get('y', 0)}
                 raise ValueError(f"Token {origin} not found")
             else:  # coordinates
                 return {"x": origin['x'], "y": origin['y']}
         
         def _filter_by_radius(self, scene_data, origin, radius):
             results = []
             objects = []
             
             # Collect all objects (walls, doors, notes, lights, tokens)
             if 'walls' in scene_data:
                 objects.extend([{'type': 'wall', 'id': w['id'], 'coordinates': self._get_wall_center(w['c'])} 
                             for w in scene_data['walls']])
             if 'doors' in scene_data:
                 objects.extend([{'type': 'door', 'id': d['id'], 'coordinates': self._get_door_center(d['c'])} 
                             for d in scene_data['doors']])
             if 'notes' in scene_data:
                 objects.extend([{'type': 'journal_note', 'id': n['id'], 'coordinates': {'x': n['x'], 'y': n['y']}} 
                             for n in scene_data['notes']])
             if 'lights' in scene_data:
                 objects.extend([{'type': 'token_light', 'id': l['id'], 'coordinates': {'x': l['x'], 'y': l['y']}} 
                             for l in scene_data['lights']])
             
             # Filter by Euclidean distance
             for obj in objects:
                 dist = self._euclidean_distance(origin, obj['coordinates'])
                 if dist <= radius:
                     obj['distance'] = dist
                     results.append(obj)
             
             return results
         
         def _filter_by_los(self, origin, objects, walls):
             visible = []
             for obj in objects:
                 if self._check_line_of_sight(origin, obj['coordinates'], walls):
                     visible.append(obj)
             return visible
         
         def _check_line_of_sight(self, origin, target, walls):
             # Cast ray from origin to target
             # Check intersections with vision-blocking walls (wall.sense = true)
             # Use simple line intersection algorithm
             for wall in walls:
                 if wall.get('blocks_vision', False):
                     if self._ray_intersects_line(origin, target, wall['coordinates']):
                         return False
             return True
         
         def _ray_intersects_line(self, origin, target, wall_coords):
             # Check if ray from origin to target intersects wall line segment
             # Using line-line intersection formula
             ox, oy = origin['x'], origin['y']
             tx, ty = target['x'], target['y']
             wx1, wy1, wx2, wy2 = wall_coords['start']['x'], wall_coords['start']['y'], wall_coords['end']['x'], wall_coords['end']['y']
             
             # Denominator for line-line intersection
             denom = (ox - tx) * (wy1 - wy2) - (oy - ty) * (wx1 - wx2)
             if denom == 0:
                 return False  # Parallel lines
             
             # Check intersection
             ua = ((wx1 - wx2) * (oy - wy1) - (wy1 - wy2) * (ox - wx1)) / denom
             ub = ((wx1 - wx2) * (oy - wy1) - (wy1 - wy2) * (ox - wx1)) / denom
             
             if 0 <= ua <= 1 and 0 <= ub <= 1:
                 return True  # Lines intersect
             return False
         
         def _euclidean_distance(self, p1, p2):
             return sqrt((p2['x'] - p1['x'])**2 + (p2['y'] - p1['y'])**2)
         
         def _sort_and_format(self, origin, objects, grid_size, distance_unit):
             # Sort by distance
             objects.sort(key=lambda o: o['distance'])
             
             # Format distances for each object
             for obj in objects:
                 grid_squares = obj['distance'] / grid_size
                 obj['formatted_distance'] = self._format_distance(grid_squares, distance_unit)
             
             return objects
         
         def _format_distance(self, grid_squares, distance_unit):
             if distance_unit['unit'] == 'squares' or distance_unit['value'] is None:
                 return f"{round(grid_squares, 1)} squares"
             
             # Calculate in user's units
             user_units = grid_squares * distance_unit['value']
             return f"{round(user_units, 1)} {distance_unit['unit']}"
         
         def _structure_output(self, objects, origin, radius, search_mode):
             # Group objects by type
             grouped = {
                 'tokens': [o for o in objects if o.get('type') == 'token'],
                 'structures': [o for o in objects if o.get('type') in ['wall', 'door']],
                 'locations_of_interest': [o for o in objects if o.get('type') == 'journal_note'],
                 'lighting': [o for o in objects if o.get('type') == 'token_light']
             }
             
             # Generate distance matrix for tokens
             tokens = [o for o in objects if o.get('type') == 'token']
             distance_matrix = self._generate_distance_matrix(origin, tokens, self.grid_size, self.distance_unit, self.max_nearest_tokens)
             
             return {
                 'nearby_scene_objects': {
                     'origin': {
                         'coordinates': origin,
                         'distance_unit': distance_unit.get('unit', 'squares'),
                         'description': 'Search center point'
                     },
                     'search_radius': radius,
                     'search_mode': search_mode,
                     'total_objects_found': len(objects),
                     'visible_objects_count': len(objects),
                     'tokens': {
                         'count': len(grouped['tokens']),
                         'items': self._format_tokens(grouped['tokens'], origin)
                     },
                     'structures': {
                         'count': len(grouped['structures']),
                         'items': self._format_structures(grouped['structures'])
                     },
                     'locations_of_interest': {
                         'count': len(grouped['locations_of_interest']),
                         'items': self._format_locations(grouped['locations_of_interest'])
                     },
                     'lighting': {
                         'count': len(grouped['lighting']),
                         'items': self._format_lighting(grouped['lighting'])
                     }
                 },
                 'distance_matrix': distance_matrix
             }
         
         def _generate_distance_matrix(self, origin, tokens, grid_size, distance_unit, max_nearest):
             """Generate pairwise distance matrix for nearest N tokens"""
             # Only include tokens
             token_distances = []
             for token in tokens:
                 dist = self._euclidean_distance(origin, token['coordinates'])
                 token_distances.append({
                     'token_id': token['id'],
                     'name': token['name'],
                     'distance': dist
                 })
             
             # Sort by distance
             token_distances.sort(key=lambda t: t['distance'])
             
             # Get nearest N (configurable)
             nearest = token_distances[:max_nearest]
             
             # Generate pairwise distances between nearest N
             pairwise = {}
             for i, token1 in enumerate(nearest):
                 distances = {}
                 for j, token2 in enumerate(nearest):
                     if i == j:
                         continue  # Skip self
                     dist = self._euclidean_distance(
                         token1['coordinates'],
                         token2['coordinates']
                     )
                     grid_dist = dist / grid_size
                     formatted = self._format_distance(grid_dist, distance_unit)
                     distances[token2['name']] = formatted
                 pairwise[token1['name']] = distances
             
             return {
                 'origin_token_id': origin.get('token_id') if isinstance(origin, dict) else None,
                 'nearest_objects': nearest,
                 'pairwise_distances': pairwise,
                 'total_tokens_in_scene': len(tokens)
             }
         
         def _format_tokens(self, tokens, origin):
             return [
                 {
                     'id': t.get('id'),
                     'name': t.get('name'),
                     'distance': t.get('formatted_distance'),
                     'bearing': self._calculate_bearing(origin, t['coordinates']),
                     'is_visible': True,  # Already filtered by LoS
                     'coordinates': t['coordinates']
                 }
                 for t in tokens
             ]
         
         def _format_structures(self, structures):
             items = []
             for s in structures:
                 if s['type'] == 'wall':
                     items.append({
                         'type': 'wall',
                         'id': s.get('id'),
                         'distance': s.get('formatted_distance'),
                         'blocks_vision': s.get('blocks_vision', False),
                         'coordinates': s['coordinates']
                     })
                 elif s['type'] == 'door':
                     items.append({
                         'type': 'door',
                         'id': s.get('id'),
                         'distance': s.get('formatted_distance'),
                         'state': s.get('state', 'unknown'),
                         'locked': s.get('locked', False),
                         'blocks_vision': s.get('blocks_vision', False),
                         'coordinates': s['coordinates']
                     })
             return items
         
         def _format_locations(self, locations):
             return [
                 {
                     'type': 'journal_note',
                     'id': l.get('id'),
                     'distance': l.get('formatted_distance'),
                     'entry_name': l.get('entry_name'),
                     'journal_entry_title': l.get('journal_entry_title'),
                     'note_type': l.get('note_type'),
                     'coordinates': l['coordinates']
                 }
                 for l in locations
             ]
         
         def _format_lighting(self, lights):
             return [
                 {
                     'type': 'token_light',
                     'source_token': l.get('source_token'),
                     'distance': l.get('formatted_distance'),
                     'radius': l.get('radius'),
                     'color': l.get('color'),
                     'brightness': l.get('brightness', 'unknown')
                 }
                 for l in lights
             ]
         
         def _calculate_bearing(self, origin, target):
             # Calculate compass direction from origin to target
             dx = target['x'] - origin['x']
             dy = target['y'] - origin['y']
             angle = atan2(dy, dx) * 180 / pi  # Degrees
             
             # Normalize to 0-360
             if angle < 0:
                 angle += 360
             
             # Map to compass directions
             directions = ['east', 'southeast', 'south', 'southwest', 'west', 'northwest', 'north', 'northeast']
             index = round(angle / 45) % 8
             return directions[index]
     
     def parse_distance_unit(setting):
         """Parse plain language distance unit setting"""
         if not setting:
             return {'unit': 'squares', 'value': None}
         
         # Extract number and unit from plain language
         import re
         match = re.match(r'(\d+(?:\.\d+)?)\s*(feet|ft|meters|m|squares)?', setting.lower())
         
         if not match:
             return {'unit': 'squares', 'value': None}
         
         value = float(match.group(1))
         unit = match.group(2) or 'squares'
         
         # Normalize unit names
         unit_map = {
             'feet': 'feet',
             'ft': 'feet',
             'meters': 'meters',
             'm': 'meters'
         }
         
         return {
             'unit': unit_map.get(unit, 'squares'),
             'value': value
         }
     ```

4. **Add Spatial Filter Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_NEARBY_OBJECTS = "get_nearby_objects"` constant
   - Add `TYPE_SPATIAL_FILTER_RESULTS = "spatial_filter_results"` constant (for responses)
   - Document message formats in protocol specification

5. **Implement Frontend Spatial Collection** (`world-state-collector.js`)
   - Add `getSpatialData()` method
   - Get current scene: `game.scenes.get(game.user.viewedScene)`
   - Collect wall data:
     ```javascript
     scene.walls.map(wall => ({
         id: wall.id,
         c: wall.document.c,  // coordinates [x1, y1, x2, y2]
         door: wall.document.door,
         blocks_vision: wall.document.sense,  // Use sense property for vision blocking
         coordinates: {
             start: {x: wall.document.c[0], y: wall.document.c[1]},
             end: {x: wall.document.c[2], y: wall.document.c[3]}
         }
     }))
     ```
   - Collect door data (subset of walls):
     ```javascript
     scene.walls.filter(w => w.document.door !== CONST.WALL_DOOR_TYPES.NONE)
         .map(door => ({
             id: door.id,
             c: door.document.c,
             door: door.document.door,
             state: door.document.doorState,  // 0=closed, 1=open, 2=locked
             locked: door.document.locked,
             blocks_vision: door.document.sense,
             coordinates: {
                 start: {x: door.document.c[0], y: door.document.c[1]},
                 end: {x: door.document.c[2], y: door.document.c[3]},
                 center: {
                     x: (door.document.c[0] + door.document.c[2]) / 2,
                     y: (door.document.c[1] + door.document.c[3]) / 2
                 }
             }
         }))
     ```
   - Collect note data:
     ```javascript
     scene.notes.map(note => ({
         id: note.id,
         entryName: note.entryName,
         entryId: note.entryId,
         journal_entry_title: note.journalEntry?.name || 'Unknown',
         note_type: note.icon || 'location',  // Foundry note type
         coordinates: {x: note.x, y: note.y}
     }))
     ```
   - Collect light source data from tokens:
     ```javascript
     canvas.tokens.placeables.filter(token => token.light && token.document.light.radius > 0)
         .map(token => ({
             id: token.id,
             source_token: token.name,
             x: token.x,
             y: token.y,
             radius: token.document.light.radius,
             color: token.document.light.color,
             brightness: token.document.light.dim > 0 ? 'dim' : 'bright'
         }))
     ```
   - Collect token data (excluding PCs if needed, or all tokens):
     ```javascript
     canvas.tokens.placeables.map(token => ({
         id: token.id,
         name: token.name,
         x: token.x,
         y: token.y,
         is_player: token.actor?.hasPlayerOwner || false,
         coordinates: {
             x: token.center.x,
             y: token.center.y
         }
     }))
     ```
   - Collect grid info:
     ```javascript
     {
         size: scene.grid.size,  // Units per square
         distance_unit: scene.grid.distance  // Feet per square (e.g., 5 for D&D)
     }
     ```
   - Handle errors (no active scene, etc.)

6. **Implement Frontend Spatial Filter Handler** (`world-state-collector.js`)
   - Add `handleGetNearbyObjects(request)` method
   - Get scene data using `getSpatialData()`
   - Send full scene data to backend (no filtering on frontend)
   - Backend handles spatial filtering with `SceneSpatialFilter`
   - Return structured results

7. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_nearby_objects` messages
   - Route to WorldStateCollector
   - Send `spatial_filter_results` responses back to backend
   - Add error handling for spatial queries

8. **Add User Settings for Spatial Filtering** (`settings-manager.js`)
   - Add `spatial` section to settings:
     ```javascript
     {
       "spatial": {
         "auto_search": {
           "enabled": true,
           "player_character_token": "",  // User's configured PC token ID
           "radius": 6,  // Default search radius
           "search_mode": "line_of_sight"
         },
         "distance_matrix": {
           "max_nearest_tokens": 5,  // Configurable, default 5
           "enabled": true
         },
         "grid_square_size": "5 feet",  // Plain language, default D&D
         "tooltip": "Enter the size of one grid square in your game system (e.g., '5 feet' for D&D, '2 meters' for Pathfinder)"
       }
     }
     ```
   - Add UI settings for spatial configuration

9. **Add Settings UI to Main HUD** (`scripts/gold-box.js`)
   - Add "Spatial Settings" section to settings menu
   - Field: "Player Character Token" with dropdown (user's tokens)
   - Field: "Auto-Search Radius" with number input
   - Field: "Search Mode" with dropdown (absolute/line_of_sight)
   - Field: "Distance Matrix Size" with number input (default 5, min 1, max 20)
   - Field: "Grid Square Size" with text input and tooltip
   - Save settings to `universal_settings`

10. **Implement Auto-Search Context Triggering** (`world-state-collector.js`)
   - Add `buildNearbyObjectsContext(user_settings, scene_data)` method
   - Check if auto-search is enabled
   - Get user's PC token from settings
   - Get auto-search radius and mode from settings
   - Build search parameters:
     ```javascript
     const origin = {
         x: pcToken.center.x,
         y: pcToken.center.y
     };
     const radius = user_settings.spatial.auto_search.radius;
     const mode = user_settings.spatial.auto_search.search_mode;
     ```
   - Send `get_nearby_objects` request to backend
   - Add results to initial context

11. **Add Distance Unit Parsing to Backend** (`backend/shared/startup/config.py` or `universal_settings.py`)
   - Add `grid_square_size` field to settings schema
   - Add `max_nearest_tokens` field to settings schema
   - Validate format (plain language: "5 feet", "2 meters")
   - Default to "5 feet"
   - Fallback to squares if invalid

12. **Add Shapely Dependency** (`backend/requirements.txt`)
   - Add `shapely>=2.0.0` to requirements
   - This enables wall shape detection

13. **Add Function Check Tests** (`function_check.sh`)
   - Test get_nearby_objects with token origin: `tool get_nearby_objects origin="<token_id>" radius=6 search_mode="line_of_sight"`
   - Test get_nearby_objects with coordinates: `tool get_nearby_objects origin='{"x":1000,"y":1500}' radius=6 search_mode="absolute"`
   - Test with different search modes
   - Verify distance units work (5 feet setting)
   - Verify fallback to squares with invalid setting
   - Verify token distances included
   - Verify line-of-sight filtering works
   - Verify distance matrix included (pairwise distances)
   - Test auto-search triggering from user's PC

### Acceptance Criteria

- [x] AI can query nearby objects around a location or token
- [x] Supports both absolute and line-of-sight search modes
- [x] Wall filtering respects Foundry's vision-blocking rules (wall.sense)
- [x] Distance reporting in user-configurable natural language units
- [x] Fallback to squares if distance setting invalid
- [x] Token distances pre-calculated and included in results
- [x] Distance matrix for nearest 5 tokens with pairwise distances
- [x] Journal notes exposed as-is (entry_name, journal_entry_title, note_type)
- [x] Auto-search triggers based on user's configured PC token
- [x] Results limited to prevent token overflow (max 30 objects total)
- [x] No spatial summaries (deferred for AI performance testing)
- [x] All tests in function_check.sh pass
- [x] No console errors during spatial filtering

---

## Feature 2: Journal Context Search

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ get_journal_context(entry_name, search_phrase, context_lines) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                              â†“
Journal context data â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `get_journal_context` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "get_journal_context",
             "description": "Searches for a phrase within a journal entry and returns the surrounding context. Returns matching text with specified number of lines before and after for context. Similar to grep -C (context) but for journal content. Use after seeing a map note to get detailed information about that location.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "entry_name": {
                         "type": "string",
                         "description": "Name of the journal entry to search"
                     },
                     "search_phrase": {
                         "type": "string",
                         "description": "Phrase to search for within the journal entry"
                     },
                     "context_lines": {
                         "type": "integer",
                         "description": "Number of lines of context before and after the match (default: 3)",
                         "default": 3,
                         "minimum": 0,
                         "maximum": 20
                     }
                 },
                 "required": ["entry_name", "search_phrase"]
             }
         }
     }
     ```

2. **Implement `get_journal_context` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_journal_context()` method
   - Validate input parameters
   - Send journal context request to frontend via WebSocket
   - Include entry_name, search_phrase, and context_lines in request
   - Await journal context response (5 second timeout)
   - Format and return journal context to AI
   - Handle timeout and error cases (entry not found, etc.)

3. **Add Journal Context Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_JOURNAL_CONTEXT = "get_journal_context"` constant
   - Add `TYPE_JOURNAL_CONTEXT = "journal_context"` constant (for responses)
   - Document message formats in protocol specification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `getJournalContext(entry_name, search_phrase, context_lines)` method
   - Find journal entry by name:
     ```javascript
     const journalEntry = game.journal.find(entry => entry.name === entry_name);
     ```
   - If not found, return error: `{"success": false, "message": "Journal entry not found"}`
   - Get text content from first page:
     ```javascript
     const text = journalEntry.pages.contents[0]?.text?.content || '';
     ```
   - Split text into lines:
     ```javascript
     const lines = text.split('\n');
     ```
   - Search for phrase (case-insensitive):
     ```javascript
     const matches = [];
     lines.forEach((line, index) => {
         if (line.toLowerCase().includes(search_phrase.toLowerCase())) {
             const start = Math.max(0, index - context_lines);
             const end = Math.min(lines.length, index + context_lines + 1);
             matches.push({
                 match: line,
                 context: lines.slice(start, end),
                 line_number: index + 1,
                 position: {start, end}
             });
         }
     });
     ```
   - Return matches array with entry metadata:
     ```javascript
     {
         entry_name: journalEntry.name,
         entry_id: journalEntry.id,
         search_phrase: search_phrase,
         matches: matches,
         total_matches: matches.length
     }
     ```
   - Handle errors (entry not found, no matches)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_journal_context` messages
   - Route to WorldStateCollector
   - Send `journal_context` responses back to backend
   - Add error handling for journal context queries

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for get_journal_context: `tool get_journal_context entry_name="<name>" search_phrase="<phrase>"`
   - Add test with custom context_lines: `tool get_journal_context entry_name="<name>" search_phrase="<phrase>" context_lines=5`
   - Test case-insensitive search
   - Test entry not found error
   - Test no matches scenario
   - Verify context lines returned correctly

### Acceptance Criteria

- [x] AI can search journal entries for specific phrases
- [x] Search is case-insensitive
- [x] Context lines returned around matches
- [x] Multiple matches found in single entry
- [x] Works with large journal entries (e.g., Sunless Citadel)
- [x] No sub-section extraction (journal notes link to full entry, AI searches when needed)
- [x] Appropriate error messages for invalid entries
- [x] All tests in function_check.sh pass
- [x] No console errors during journal context queries

---

## Feature 3: Compendium Search

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ search_compendium(pack_name, query) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                  â†“
Compendium search results â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `search_compendium` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "search_compendium",
             "description": "Searches within a specific compendium pack for entries matching a query. Returns matching entries with their names, IDs, and key information. Use to find items, spells, monsters, or other game content in compendiums.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "pack_name": {
                         "type": "string",
                         "description": "Name of the compendium pack to search (e.g., 'dnd5e.items', 'dnd5e.spells', 'world.lore-journals')"
                     },
                     "query": {
                         "type": "string",
                         "description": "Search query text (case-insensitive, partial matches allowed)"
                     }
                 },
                 "required": ["pack_name", "query"]
             }
         }
     }
     ```

2. **Implement `search_compendium` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_search_compendium()` method
   - Validate input parameters
   - Send compendium search request to frontend via WebSocket
   - Include pack_name and query in request
   - Await compendium search response (5 second timeout)
   - Format and return compendium search results to AI
   - Handle timeout and error cases (pack not found, etc.)

3. **Add Compendium Search Message Types** (`message_protocol.py`)
   - Add `TYPE_SEARCH_COMPENDIUM = "search_compendium"` constant
   - Add `TYPE_COMPENDIUM_RESULTS = "compendium_results"` constant (for responses)
   - Document message formats in protocol specification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `searchCompendium(pack_name, query)` method
   - Find compendium pack:
     ```javascript
     const pack = game.packs.get(pack_name);
     ```
   - If not found, return error: `{"success": false, "message": "Compendium pack not found"}`
   - Get compendium index:
     ```javascript
     const index = await pack.getIndex();
     ```
   - Filter index for matches (case-insensitive):
     ```javascript
     const matches = index.filter(entry => 
         entry.name.toLowerCase().includes(query.toLowerCase())
     );
     ```
   - Get full documents for matches (limit to top 20):
     ```javascript
     const topMatches = matches.slice(0, 20);
     const documents = await pack.getDocuments(topMatches.map(m => m._id));
     ```
   - Format results:
     ```javascript
     documents.map(doc => ({
         id: doc.id,
         name: doc.name,
         type: doc.type,
         img: doc.img,
         // Add system-specific fields based on type
         system: {
             // For items: value, weight, etc.
             // For actors: hp, ac, etc.
             // For spells: level, school, etc.
         }
     }))
     ```
   - Return results with metadata:
     ```javascript
     {
         pack_name: pack_name,
         query: query,
         total_matches: matches.length,
         returned_matches: documents.length,
         results: formatted_documents
     }
     ```
   - Handle errors (pack not found, no matches)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `search_compendium` messages
   - Route to WorldStateCollector
   - Send `compendium_results` responses back to backend
   - Add error handling for compendium searches

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for search_compendium: `tool search_compendium pack_name="dnd5e.items" query="sword"`
   - Add test for spells: `tool search_compendium pack_name="dnd5e.spells" query="fireball"`
   - Add test for monsters: `tool search_compendium pack_name="dnd5e.monsters" query="goblin"`
   - Test case-insensitive search
   - Test pack not found error
   - Test no matches scenario
   - Verify results include relevant system data

### Acceptance Criteria

- [x] AI can search compendium packs for entries
- [x] Search is case-insensitive
- [x] Results include key information (name, type, system data)
- [x] Works with different pack types (items, spells, monsters, journals)
- [x] Results limited to reasonable number (top 20)
- [x] Appropriate error messages for invalid packs
- [x] All tests in function_check.sh pass
- [x] No console errors during compendium searches

---

## Feature 4: Party Member Tracking

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ get_party_members() â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                        â†“
Party members data â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `get_party_members` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with no parameters
   - Validate no parameters required
   - Add description: "Returns a list of all player-controlled characters (PCs) in the session. Includes character names, player names, and basic information for party composition awareness."

2. **Implement `get_party_members` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_party_members()` method
   - Send party members request to frontend via WebSocket
   - Await party members response (5 second timeout)
   - Format and return party members data to AI
   - Handle timeout and error cases

3. **Add Party Members Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_PARTY_MEMBERS = "get_party_members"` constant
   - Add `TYPE_PARTY_MEMBERS = "party_members"` constant (for responses)
   - Document message formats in protocol specification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `getPartyMembers()` method
   - Get all actors:
     ```javascript
     game.actors.filter(actor => actor.hasPlayerOwner)
     ```
   - Format results:
     ```javascript
     actors.map(actor => ({
         id: actor.id,
         name: actor.name,
         type: actor.type,
         img: actor.img,
         owners: actor.owners.map(owner => ({
             id: owner.id,
             name: game.users.get(owner.id)?.name || 'Unknown',
             is_active: owner.active
         })),
         system: {
             // Add basic system data
             hp: actor.system.attributes?.hp,
             ac: actor.system.attributes?.ac
         }
     }))
     ```
   - Return results:
     ```javascript
     {
         total_party_members: formatted_actors.length,
         members: formatted_actors
     }
     ```
   - Handle errors (no party members)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_party_members` messages
   - Route to WorldStateCollector
   - Send `party_members` responses back to backend
   - Add error handling for party member queries

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for get_party_members: `tool get_party_members`
   - Verify returns all player-owned characters
   - Verify includes owner information
   - Verify handles empty party

### Acceptance Criteria

- [x] AI can query party member information
- [x] Returns all player-owned characters
- [x] Includes owner/player information
- [x] Includes basic system data (HP, AC)
- [x] Appropriate error messages for empty party
- [x] All tests in function_check.sh pass
- [x] No console errors during party member queries

---

## Feature 5: Enhanced Delta Tracking

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/message_services/message_delta_service.py` (new deltas)
- `backend/services/message_services/websocket_message_collector.py` (track new deltas)
- `scripts/api/combat-monitor.js` (transmit new deltas)
- `scripts/services/world-state-collector.js` (track scene deltas)
- `backend/testing/function_check.sh` (delta tests)

### Tasks

1. **Add SceneChanged Delta** (`message_delta_service.py`)
   - Add `SceneChanged` field to delta format
   - Structure:
     ```json
     {
       "new_scene_id": "string",
       "new_scene_name": "string"
     }
     ```
   - Clear after AI turn completes

2. **Add TokenMoved Delta** (`message_delta_service.py`)
   - Add `TokenMoved` field to delta format
   - Structure:
     ```json
     {
       "token_id": "string",
       "old_position": {"x": number, "y": number},
       "new_position": {"x": number, "y": number}
     }
     ```
   - Clear after AI turn completes

3. **Add SceneNoteUpdated Delta** (`message_delta_service.py`)
   - Add `SceneNoteUpdated` field to delta format
   - Structure:
     ```json
     {
       "note_id": "string",
       "entry_name": "string",
       "position": {"x": number, "y": number}
     }
     ```
   - Clear after AI turn completes

4. **Track Scene Changes in Frontend** (`world-state-collector.js`)
   - On `updateScene` hook (scene changes):
     - Set `SceneChanged` in delta with new scene ID and name
     - Send delta to backend via WebSocket

5. **Track Token Movements in Frontend** (`world-state-collector.js`)
   - On `updateToken` hook (token position changes):
     - Detect position changes
     - Track token_id, old_position, new_position
     - Set `TokenMoved` in delta with relevant data
     - Send delta to backend via WebSocket

6. **Track Note Updates in Frontend** (`world-state-collector.js`)
   - On `updateNote` hook (note changes):
     - Detect note updates
     - Track note_id, entry_name, position
     - Set `SceneNoteUpdated` in delta with relevant data
     - Send delta to backend via WebSocket

7. **Add Delta Tests** (`function_check.sh`)
   - Test SceneChanged delta after scene change
   - Test TokenMoved delta after token movement
   - Test SceneNoteUpdated delta after note update
   - Verify deltas cleared after AI turn

### Acceptance Criteria

- [x] SceneChanged delta tracks scene changes
- [x] TokenMoved delta tracks token position changes
- [x] SceneNoteUpdated delta tracks note updates
- [x] Deltas transmitted from frontend to backend
- [x] Deltas included in AI context when changes occur
- [x] Deltas cleared after AI turn completes
- [x] Live testing confirms delta tracking working correctly

---

## Feature 6: Initial Context Expansion

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `scripts/services/world-state-collector.js` (enhance initial context)
- `backend/services/message_services/context_builder.py` (update context structure)

### Tasks

1. **Add Auto-Search to Initial Context** (`world-state-collector.js`)
   - Modify `getWorldStateOverview()` to include auto-search
   - Check if auto-search is enabled in settings
   - Get user's PC token from settings
   - Call `buildNearbyObjectsContext()` if PC token found
   - Add `nearby_scene_objects` to initial context

2. **Add compendium_index to World State** (`world-state-collector.js`)
   - Add `compendium_index` object to root of World State Overview:
     ```javascript
     {
         "pack_name": "dnd5e.monsters",
         "type": "Actor"
     }
     ```
   - Scan all available compendium packs:
     ```javascript
     game.packs.map(pack => ({
         pack_name: pack.collection,
         type: pack.metadata.type,
         entity: pack.metadata.entity
     }))
     ```
   - Include world and system compendiums

3. **Verify Context Structure** (`context_builder.py`)
   - Ensure expanded World State Overview is properly formatted
   - Verify JSON structure matches expected schema
   - Test with real Foundry session data

4. **Add Initial Context Tests** (`function_check.sh`)
   - Test that initial context includes nearby_scene_objects when auto-search enabled
   - Test that initial context includes compendium_index
   - Verify all required fields present
   - Test that auto-search respects user's PC token setting

### Acceptance Criteria

- [x] Auto-search triggers based on user's configured PC token
- [x] Initial context includes nearby_scene_objects when enabled
- [x] Initial context includes compendium_index
- [x] All compendium packs indexed
- [x] Context structure validated
- [x] All tests in function_check.sh pass

---

## Feature 7: Testing Infrastructure

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/testing/function_check.sh` (comprehensive test suite)

### Tasks

1. **Add Spatial Filtering Tests**
   - Test get_nearby_objects with token origin
   - Test get_nearby_objects with coordinates
   - Test absolute vs line-of-sight modes
   - Test distance unit conversion (5 feet, 2 meters, squares fallback)
   - Test token distances included
   - Test auto-search triggering
   - Test distance matrix (pairwise distances)

2. **Add Knowledge Discovery Tests**
   - Test get_journal_context with various phrases
   - Test search_compendium with different pack types
   - Test get_party_members

3. **Add Delta Tracking Tests**
   - Test SceneChanged delta
   - Test TokenMoved delta
   - Test SceneNoteUpdated delta

4. **Integration Tests**
   - Spatial awareness workflow: get nearby objects â†’ verify distances
   - Knowledge search workflow: search compendium â†’ get journal context
   - Party awareness workflow: get party members â†’ query individual actors
   - Auto-search workflow: trigger based on PC token â†’ verify spatial context
   - Delta tracking throughout scene changes

### Acceptance Criteria

- [x] All new tools tested individually
- [x] Integration tests validate complete workflows
- [x] All tests pass
- [x] Test documentation complete

---

## Feature 8: Documentation

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `CHANGELOG.md` (update)
- `ROADMAP.md` (update)
- `USAGE.md` (update if needed)

### Tasks

1. **Update CHANGELOG.md**
   - Create new section `## [0.3.11] - 2026-01-XX`
   - Document new features:
     - Unified spatial filtering system with configurable distance units
     - Distance matrix for nearest 5 tokens with pairwise distances
     - Journal context search
     - Compendium search
     - Party member tracking
     - Enhanced delta tracking (scene changes, token movements, note updates)
     - Auto-search based on user's PC token
     - Initial context expansion (nearby_objects, compendium_index)
   - Document any breaking changes
   - Document any migration notes

2. **Update ROADMAP.md**
   - Mark Patch 0.3.11 items as complete
   - Update progress indicators
   - Note any deviations from original plan

3. **Update USAGE.md** (if needed)
   - Add examples of new tools
   - Add workflow examples for spatial awareness
   - Add examples for knowledge discovery
   - Document spatial settings configuration

### Acceptance Criteria

- [ ] All changes documented in CHANGELOG.md
- [ ] ROADMAP.md updated with completion status
- [ ] Tool documentation complete

---

## Implementation Order

Recommended implementation sequence based on dependencies:

1. **Feature 5: Enhanced Delta Tracking** (foundational - deltas need to be ready before features use them)
2. **Feature 1: Unified Spatial Filtering System** (core feature, most complex)
3. **Feature 2: Journal Context Search** (independent feature)
4. **Feature 3: Compendium Search** (independent feature)
5. **Feature 4: Party Member Tracking** (independent feature)
6. **Feature 6: Initial Context Expansion** (depends on Feature 1)
7. **Feature 7: Testing Infrastructure** (validation)
8. **Feature 8: Documentation** (finalization)

---

## Testing Checklist

Before merging to main:

### Function Check Tests
- [ ] get_nearby_objects returns structured spatial data
- [ ] get_nearby_objects respects absolute vs line-of-sight modes
- [ ] get_nearby_objects includes token distances in user-configured units
- [ ] Distance unit parsing works (5 feet, 2 meters, squares fallback)
- [ ] get_nearby_objects includes distance matrix for nearest 5 tokens
- [ ] get_journal_context returns matching context
- [ ] search_compendium returns relevant results
- [ ] get_party_members returns player-owned characters
- [ ] SceneChanged delta appears after scene change
- [ ] TokenMoved delta appears after token movement
- [ ] SceneNoteUpdated delta appears after note update

### Integration Tests
- [ ] Spatial awareness workflow (radius search with distances)
- [ ] Knowledge search workflow (compendium â†’ journal context)
- [ ] Party awareness workflow (party members â†’ actor details)
- [ ] Auto-search workflow (PC token trigger â†’ spatial context)
- [ ] Delta tracking throughout scene changes

### Manual Testing
- [ ] Module loads without errors
- [ ] AI can query nearby objects around locations
- [ ] AI can search journal entries
- [ ] AI can search compendium packs
- [ ] AI can get party member information
- [ ] Spatial settings UI works correctly
- [ ] Distance unit configuration works (5 feet, 2 meters, squares)
- [ ] Distance matrix configuration works (size 5 default)
- [ ] Auto-search triggers based on user's PC token
- [ ] Initial context includes nearby_scene_objects when enabled
- [ ] Deltas appear correctly between AI turns
- [ ] No console errors

---

## Branch Management

### Create Feature Branch
```bash
git checkout main
git pull origin main
git checkout -b feature/0.3.11-the-observer
```

### Commit Strategy
- Separate commits per feature for easier review
- Use descriptive commit messages with prefixes:
  - `feat:` for new features
  - `refactor:` for code refactoring
  - `fix:` for bug fixes
  - `docs:` for documentation

### Merge to Main
```bash
git checkout main
git merge feature/0.3.11-the-observer
git push origin main
```

### Tag Release
```bash
git tag v0.3.11
git push origin v0.3.11
```

---

## Release Notes

### New Features
- Unified spatial filtering system (`get_nearby_objects`) with radius-based searching
- Two search modes: absolute (all objects) and line-of-sight (visible only)
- User-configurable distance units (plain language: "5 feet", "2 meters", defaults to squares)
- Pre-calculated token distances included in spatial queries
- Distance matrix for nearest 5 tokens with pairwise distances (tokens only, configurable size)
- Journal context search for detailed information about map notes
- Compendium search for items, spells, monsters, etc.
- Party member tracking for party composition awareness
- Enhanced delta tracking for scene changes, token movements, note updates
- Auto-search triggering based on user's configured PC token
- Initial context expansion with nearby_objects and compendium_index

### Breaking Changes
- None

### Migration Notes
- No manual migration required for existing installations
- All features backward compatible
- Users should configure their PC token in settings for auto-search functionality
- Shapely dependency added for wall shape detection (future feature)

---

**End of Implementation Plan**
