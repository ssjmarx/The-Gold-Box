# Implementation Plan: Patch 0.3.11 - The Observer

**Version:** 0.3.11  
**Branch:** `feature/0.3.11-the-observer`  
**Status:** ðŸš§ IN PLANNING  
**Goal:** Provide the AI with deep contextual awareness of the physical environment and the game's lore, giving it "eyes" and "ears" to understand the *where* and the *why*

---

## Overview

Patch 0.3.11 implements location-based spatial awareness and knowledge discovery tools as outlined in ROADMAP.md. This patch focuses on giving the AI the ability to understand the physical environment through a unified spatial filtering system, access game lore (journal entries, compendium), and track party composition. The implementation builds on the foundation established in 0.3.9 and combat features in 0.3.10.

### Key Deliverables

1. **Unified Spatial Filtering** - Single tool for location-based scene object queries with configurable units
2. **Journal Context Search** - Search within journal entries for specific information
3. **Compendium Search** - Search compendium packs for items, spells, monsters, etc.
4. **Party Member Tracking** - Get list of all player-controlled characters
5. **Enhanced Delta Tracking** - Track scene changes, token movements, and note updates
6. **Initial Context Expansion** - Auto-trigger spatial searches based on user's PC token
7. **User-Configurable Distance Units** - System-agnostic natural language distance reporting
8. **Distance Matrix for Nearest Tokens** - Pairwise distances between top 5 tokens
9. **Wall Shape Detection with Shapely** - Detect rectangles, squares, circles, polygons

---

## Feature 1: Unified Spatial Filtering System

**Priority:** High  
**Complexity:** High  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/services/spatial_services/scene_spatial_filter.py` (NEW service)
- `scripts/services/settings-manager.js` (new spatial settings)
- `scripts/gold-box.js` (settings UI)
- `backend/testing/function_check.sh` (test cases)
- `backend/requirements.txt` (add shapely dependency)

### Architecture

```
AI â†’ get_nearby_objects(origin, radius, search_mode) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                  â†“
Scene data (walls, doors, notes, lights, tokens) â†’ Backend processing
                                                                  â†“
Filtered objects with distances â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

**Core Concept:**
- **Minecraft-style "chunking"**: AI queries spatial area around origin point
- **Radius-based filtering**: Get objects within configurable radius
- **Two search modes**: Absolute (all objects) vs Line-of-Sight (visible only)
- **User-configurable units**: Plain language "5 feet", "2 meters", defaults to squares
- **Token distances included**: Pre-calculated distances to other tokens
- **Distance matrix for nearest 5**: Pairwise distances between closest tokens
- **No spatial summaries yet**: Test AI performance before adding complexity

### Tasks

1. **Implement `get_nearby_objects` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "get_nearby_objects",
             "description": "Get scene objects within a radius of a location or token. Use absolute mode for all objects in radius, or line-of-sight mode for only visible objects (respects vision-blocking walls). Distances are reported in user-configured units (default: 5 feet). Enables spatial awareness for room descriptions, trap detection, spell targeting, environmental understanding. Example: Search around a token you want to target with Fireball to determine which enemies are within spell range.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "origin": {
                         "oneOf": [
                             {
                                 "type": "object",
                                 "properties": {
                                     "x": {"type": "number"},
                                     "y": {"type": "number"}
                                 }
                             },
                             {"type": "string"}
                         ],
                         "description": "Search origin: absolute coordinates {x: 1000, y: 1500} or token_id (uses token center)"
                     },
                     "radius": {
                         "type": "number",
                         "description": "Search radius in grid units (default: 6 = 30ft in 5ft grids)",
                         "default": 6
                     },
                     "search_mode": {
                         "type": "string",
                         "enum": ["absolute", "line_of_sight"],
                         "description": "absolute: all objects in radius, line_of_sight: only visible objects (respects walls)",
                         "default": "line_of_sight"
                     }
                 },
                 "required": ["origin"]
             }
         }
     }
     ```

2. **Implement `get_nearby_objects` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_nearby_objects()` method
   - Validate input parameters (origin, radius, search_mode)
   - Send spatial filter request to frontend via WebSocket
   - Include origin, radius, and search_mode in request
   - Await spatial filter response (5 second timeout)
   - Format and return filtered objects with distances to AI
   - Handle timeout and error cases

3. **Create Scene Spatial Filter Service** (`backend/services/spatial_services/scene_spatial_filter.py`)
   - Create new service file: `scene_spatial_filter.py`
   - Implement `SceneSpatialFilter` class:
     ```python
     class SceneSpatialFilter:
         def __init__(self, grid_size, distance_unit_setting, max_nearest_tokens=5):
             self.grid_size = grid_size  # Foundry grid size (units per square)
             self.distance_unit = parse_distance_unit(distance_unit_setting)
             self.max_nearest_tokens = max_nearest_tokens
         
         def get_nearby_objects(self, scene_data, origin, radius, search_mode):
             # 1. Parse origin (coordinates or token center)
             origin_coords = self._parse_origin(origin, scene_data.get('tokens', []))
             
             # 2. Filter objects by radius (Euclidean distance)
             in_radius = self._filter_by_radius(scene_data, origin_coords, radius)
             
             # 3. If line-of-sight mode: filter by visibility
             if search_mode == "line_of_sight":
                 visible = self._filter_by_los(origin_coords, in_radius, scene_data.get('walls', []))
             else:
                 visible = in_radius
             
             # 4. Sort by distance and format output
             sorted_objects = self._sort_and_format(origin_coords, visible, self.grid_size, self.distance_unit)
             
             # 5. Structure output hierarchically
             return self._structure_output(sorted_objects, origin, radius, search_mode)
         
         def _parse_origin(self, origin, tokens):
             if isinstance(origin, str):  # token_id
                 token = next((t for t in tokens if t.get('id') == origin), None)
                 if token:
                     return {"x": token.get('x', 0), "y": token.get('y', 0)}
                 raise ValueError(f"Token {origin} not found")
             else:  # coordinates
                 return {"x": origin['x'], "y": origin['y']}
         
         def _filter_by_radius(self, scene_data, origin, radius):
             results = []
             objects = []
             
             # Collect all objects (walls, doors, notes, lights, tokens)
             if 'walls' in scene_data:
                 objects.extend([{'type': 'wall', 'id': w['id'], 'coordinates': self._get_wall_center(w['c'])} 
                             for w in scene_data['walls']])
             if 'doors' in scene_data:
                 objects.extend([{'type': 'door', 'id': d['id'], 'coordinates': self._get_door_center(d['c'])} 
                             for d in scene_data['doors']])
             if 'notes' in scene_data:
                 objects.extend([{'type': 'journal_note', 'id': n['id'], 'coordinates': {'x': n['x'], 'y': n['y']}} 
                             for n in scene_data['notes']])
             if 'lights' in scene_data:
                 objects.extend([{'type': 'token_light', 'id': l['id'], 'coordinates': {'x': l['x'], 'y': l['y']}} 
                             for l in scene_data['lights']])
             
             # Filter by Euclidean distance
             for obj in objects:
                 dist = self._euclidean_distance(origin, obj['coordinates'])
                 if dist <= radius:
                     obj['distance'] = dist
                     results.append(obj)
             
             return results
         
         def _filter_by_los(self, origin, objects, walls):
             visible = []
             for obj in objects:
                 if self._check_line_of_sight(origin, obj['coordinates'], walls):
                     visible.append(obj)
             return visible
         
         def _check_line_of_sight(self, origin, target, walls):
             # Cast ray from origin to target
             # Check intersections with vision-blocking walls (wall.sense = true)
             # Use simple line intersection algorithm
             for wall in walls:
                 if wall.get('blocks_vision', False):
                     if self._ray_intersects_line(origin, target, wall['coordinates']):
                         return False
             return True
         
         def _ray_intersects_line(self, origin, target, wall_coords):
             # Check if ray from origin to target intersects wall line segment
             # Using line-line intersection formula
             ox, oy = origin['x'], origin['y']
             tx, ty = target['x'], target['y']
             wx1, wy1, wx2, wy2 = wall_coords['start']['x'], wall_coords['start']['y'], wall_coords['end']['x'], wall_coords['end']['y']
             
             # Denominator for line-line intersection
             denom = (ox - tx) * (wy1 - wy2) - (oy - ty) * (wx1 - wx2)
             if denom == 0:
                 return False  # Parallel lines
             
             # Check intersection
             ua = ((wx1 - wx2) * (oy - wy1) - (wy1 - wy2) * (ox - wx1)) / denom
             ub = ((wx1 - wx2) * (oy - wy1) - (wy1 - wy2) * (ox - wx1)) / denom
             
             if 0 <= ua <= 1 and 0 <= ub <= 1:
                 return True  # Lines intersect
             return False
         
         def _euclidean_distance(self, p1, p2):
             return sqrt((p2['x'] - p1['x'])**2 + (p2['y'] - p1['y'])**2)
         
         def _sort_and_format(self, origin, objects, grid_size, distance_unit):
             # Sort by distance
             objects.sort(key=lambda o: o['distance'])
             
             # Format distances for each object
             for obj in objects:
                 grid_squares = obj['distance'] / grid_size
                 obj['formatted_distance'] = self._format_distance(grid_squares, distance_unit)
             
             return objects
         
         def _format_distance(self, grid_squares, distance_unit):
             if distance_unit['unit'] == 'squares' or distance_unit['value'] is None:
                 return f"{round(grid_squares, 1)} squares"
             
             # Calculate in user's units
             user_units = grid_squares * distance_unit['value']
             return f"{round(user_units, 1)} {distance_unit['unit']}"
         
         def _structure_output(self, objects, origin, radius, search_mode):
             # Group objects by type
             grouped = {
                 'tokens': [o for o in objects if o.get('type') == 'token'],
                 'structures': [o for o in objects if o.get('type') in ['wall', 'door']],
                 'locations_of_interest': [o for o in objects if o.get('type') == 'journal_note'],
                 'lighting': [o for o in objects if o.get('type') == 'token_light']
             }
             
             # Generate distance matrix for tokens
             tokens = [o for o in objects if o.get('type') == 'token']
             distance_matrix = self._generate_distance_matrix(origin, tokens, self.grid_size, self.distance_unit, self.max_nearest_tokens)
             
             return {
                 'nearby_scene_objects': {
                     'origin': {
                         'coordinates': origin,
                         'distance_unit': distance_unit.get('unit', 'squares'),
                         'description': 'Search center point'
                     },
                     'search_radius': radius,
                     'search_mode': search_mode,
                     'total_objects_found': len(objects),
                     'visible_objects_count': len(objects),
                     'tokens': {
                         'count': len(grouped['tokens']),
                         'items': self._format_tokens(grouped['tokens'], origin)
                     },
                     'structures': {
                         'count': len(grouped['structures']),
                         'items': self._format_structures(grouped['structures'])
                     },
                     'locations_of_interest': {
                         'count': len(grouped['locations_of_interest']),
                         'items': self._format_locations(grouped['locations_of_interest'])
                     },
                     'lighting': {
                         'count': len(grouped['lighting']),
                         'items': self._format_lighting(grouped['lighting'])
                     }
                 },
                 'distance_matrix': distance_matrix
             }
         
         def _generate_distance_matrix(self, origin, tokens, grid_size, distance_unit, max_nearest):
             """Generate pairwise distance matrix for nearest N tokens"""
             # Only include tokens
             token_distances = []
             for token in tokens:
                 dist = self._euclidean_distance(origin, token['coordinates'])
                 token_distances.append({
                     'token_id': token['id'],
                     'name': token['name'],
                     'distance': dist
                 })
             
             # Sort by distance
             token_distances.sort(key=lambda t: t['distance'])
             
             # Get nearest N (configurable)
             nearest = token_distances[:max_nearest]
             
             # Generate pairwise distances between nearest N
             pairwise = {}
             for i, token1 in enumerate(nearest):
                 distances = {}
                 for j, token2 in enumerate(nearest):
                     if i == j:
                         continue  # Skip self
                     dist = self._euclidean_distance(
                         token1['coordinates'],
                         token2['coordinates']
                     )
                     grid_dist = dist / grid_size
                     formatted = self._format_distance(grid_dist, distance_unit)
                     distances[token2['name']] = formatted
                 pairwise[token1['name']] = distances
             
             return {
                 'origin_token_id': origin.get('token_id') if isinstance(origin, dict) else None,
                 'nearest_objects': nearest,
                 'pairwise_distances': pairwise,
                 'total_tokens_in_scene': len(tokens)
             }
         
         def _format_tokens(self, tokens, origin):
             return [
                 {
                     'id': t.get('id'),
                     'name': t.get('name'),
                     'distance': t.get('formatted_distance'),
                     'bearing': self._calculate_bearing(origin, t['coordinates']),
                     'is_visible': True,  # Already filtered by LoS
                     'coordinates': t['coordinates']
                 }
                 for t in tokens
             ]
         
         def _format_structures(self, structures):
             items = []
             for s in structures:
                 if s['type'] == 'wall':
                     items.append({
                         'type': 'wall',
                         'id': s.get('id'),
                         'distance': s.get('formatted_distance'),
                         'blocks_vision': s.get('blocks_vision', False),
                         'coordinates': s['coordinates']
                     })
                 elif s['type'] == 'door':
                     items.append({
                         'type': 'door',
                         'id': s.get('id'),
                         'distance': s.get('formatted_distance'),
                         'state': s.get('state', 'unknown'),
                         'locked': s.get('locked', False),
                         'blocks_vision': s.get('blocks_vision', False),
                         'coordinates': s['coordinates']
                     })
             return items
         
         def _format_locations(self, locations):
             return [
                 {
                     'type': 'journal_note',
                     'id': l.get('id'),
                     'distance': l.get('formatted_distance'),
                     'entry_name': l.get('entry_name'),
                     'journal_entry_title': l.get('journal_entry_title'),
                     'note_type': l.get('note_type'),
                     'coordinates': l['coordinates']
                 }
                 for l in locations
             ]
         
         def _format_lighting(self, lights):
             return [
                 {
                     'type': 'token_light',
                     'source_token': l.get('source_token'),
                     'distance': l.get('formatted_distance'),
                     'radius': l.get('radius'),
                     'color': l.get('color'),
                     'brightness': l.get('brightness', 'unknown')
                 }
                 for l in lights
             ]
         
         def _calculate_bearing(self, origin, target):
             # Calculate compass direction from origin to target
             dx = target['x'] - origin['x']
             dy = target['y'] - origin['y']
             angle = atan2(dy, dx) * 180 / pi  # Degrees
             
             # Normalize to 0-360
             if angle < 0:
                 angle += 360
             
             # Map to compass directions
             directions = ['east', 'southeast', 'south', 'southwest', 'west', 'northwest', 'north', 'northeast']
             index = round(angle / 45) % 8
             return directions[index]
     
     def parse_distance_unit(setting):
         """Parse plain language distance unit setting"""
         if not setting:
             return {'unit': 'squares', 'value': None}
         
         # Extract number and unit from plain language
         import re
         match = re.match(r'(\d+(?:\.\d+)?)\s*(feet|ft|meters|m|squares)?', setting.lower())
         
         if not match:
             return {'unit': 'squares', 'value': None}
         
         value = float(match.group(1))
         unit = match.group(2) or 'squares'
         
         # Normalize unit names
         unit_map = {
             'feet': 'feet',
             'ft': 'feet',
             'meters': 'meters',
             'm': 'meters'
         }
         
         return {
             'unit': unit_map.get(unit, 'squares'),
             'value': value
         }
     ```

4. **Add Spatial Filter Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_NEARBY_OBJECTS = "get_nearby_objects"` constant
   - Add `TYPE_SPATIAL_FILTER_RESULTS = "spatial_filter_results"` constant (for responses)
   - Document message formats in protocol specification

5. **Implement Frontend Spatial Collection** (`world-state-collector.js`)
   - Add `getSpatialData()` method
   - Get current scene: `game.scenes.get(game.user.viewedScene)`
   - Collect wall data:
     ```javascript
     scene.walls.map(wall => ({
         id: wall.id,
         c: wall.document.c,  // coordinates [x1, y1, x2, y2]
         door: wall.document.door,
         blocks_vision: wall.document.sense,  // Use sense property for vision blocking
         coordinates: {
             start: {x: wall.document.c[0], y: wall.document.c[1]},
             end: {x: wall.document.c[2], y: wall.document.c[3]}
         }
     }))
     ```
   - Collect door data (subset of walls):
     ```javascript
     scene.walls.filter(w => w.document.door !== CONST.WALL_DOOR_TYPES.NONE)
         .map(door => ({
             id: door.id,
             c: door.document.c,
             door: door.document.door,
             state: door.document.doorState,  // 0=closed, 1=open, 2=locked
             locked: door.document.locked,
             blocks_vision: door.document.sense,
             coordinates: {
                 start: {x: door.document.c[0], y: door.document.c[1]},
                 end: {x: door.document.c[2], y: door.document.c[3]},
                 center: {
                     x: (door.document.c[0] + door.document.c[2]) / 2,
                     y: (door.document.c[1] + door.document.c[3]) / 2
                 }
             }
         }))
     ```
   - Collect note data:
     ```javascript
     scene.notes.map(note => ({
         id: note.id,
         entryName: note.entryName,
         entryId: note.entryId,
         journal_entry_title: note.journalEntry?.name || 'Unknown',
         note_type: note.icon || 'location',  // Foundry note type
         coordinates: {x: note.x, y: note.y}
     }))
     ```
   - Collect light source data from tokens:
     ```javascript
     canvas.tokens.placeables.filter(token => token.light && token.document.light.radius > 0)
         .map(token => ({
             id: token.id,
             source_token: token.name,
             x: token.x,
             y: token.y,
             radius: token.document.light.radius,
             color: token.document.light.color,
             brightness: token.document.light.dim > 0 ? 'dim' : 'bright'
         }))
     ```
   - Collect token data (excluding PCs if needed, or all tokens):
     ```javascript
     canvas.tokens.placeables.map(token => ({
         id: token.id,
         name: token.name,
         x: token.x,
         y: token.y,
         is_player: token.actor?.hasPlayerOwner || false,
         coordinates: {
             x: token.center.x,
             y: token.center.y
         }
     }))
     ```
   - Collect grid info:
     ```javascript
     {
         size: scene.grid.size,  // Units per square
         distance_unit: scene.grid.distance  // Feet per square (e.g., 5 for D&D)
     }
     ```
   - Handle errors (no active scene, etc.)

6. **Implement Frontend Spatial Filter Handler** (`world-state-collector.js`)
   - Add `handleGetNearbyObjects(request)` method
   - Get scene data using `getSpatialData()`
   - Send full scene data to backend (no filtering on frontend)
   - Backend handles spatial filtering with `SceneSpatialFilter`
   - Return structured results

7. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_nearby_objects` messages
   - Route to WorldStateCollector
   - Send `spatial_filter_results` responses back to backend
   - Add error handling for spatial queries

8. **Add User Settings for Spatial Filtering** (`settings-manager.js`)
   - Add spatial settings to settings registration:
     ```javascript
     // Auto-Search Settings
     game.settings.register(this.moduleName, 'autoSearchEnabled', {
       name: "Enable Auto-Search",
       hint: "Automatically provide spatial context to AI at start of each turn. Uses a fallback chain: user's configured PC token â†’ first player-owned token â†’ first non-player token",
       scope: "world",
       config: true,
       type: Boolean,
       default: true,
       group: "spatial"
     });

     game.settings.register(this.moduleName, 'autoSearchRadius', {
       name: "Auto-Search Radius",
       hint: "Search radius in grid units for auto-generated spatial context (default: 6 = 30ft in 5ft grids)",
       scope: "world",
       config: true,
       type: Number,
       default: 6,
       group: "spatial"
     });

     game.settings.register(this.moduleName, 'autoSearchMode', {
       name: "Auto-Search Mode",
       hint: "Search mode for auto-generated spatial context",
       scope: "world",
       config: true,
       type: String,
       choices: {
         "absolute": "Absolute (all objects)",
         "line_of_sight": "Line-of-Sight (visible only)"
       },
       default: "line_of_sight",
       group: "spatial"
     });
     ```
   - Note: Uses Foundry's built-in `user.character` property for PC token selection

9. **Add Settings UI to Main HUD** (`scripts/gold-box.js`)
   - Add "Spatial Settings" section to settings menu
   - Field: "Enable Auto-Search" with checkbox
   - Field: "Auto-Search Radius" with number input (default: 6)
   - Field: "Auto-Search Mode" with dropdown (absolute/line_of_sight)
   - Field: "Distance Matrix Size" with number input (default 5, min 1, max 20)
   - Field: "Grid Square Size" with text input and tooltip
   - Note: User's PC token is configured in Foundry's user settings (Configuration â†’ Player Character), not in Gold Box settings

10. **Implement Auto-Search Context Triggering with Fallback Logic** (`world-state-collector.js`)
   - Add `getSpatialSearchOrigin(sceneData)` method that implements fallback chain:
     ```javascript
     getSpatialSearchOrigin(sceneData) {
         // Step 1: Try current user's configured player character
         const currentUser = game.user;
         if (currentUser && currentUser.character) {
             const pcActor = game.actors.get(currentUser.character.id);
             if (pcActor) {
                 // Find all tokens for this actor in scene
                 const actorTokens = sceneData.tokens.filter(t => t.actor_id === pcActor.id);
                 if (actorTokens.length > 0) {
                     const firstToken = actorTokens[0];
                     console.log(`Spatial search: Using user's PC token ${firstToken.name}`);
                     return {
                         token_id: firstToken.id,
                         token_name: firstToken.name,
                         actor_id: pcActor.id,
                         coordinates: { x: firstToken.x, y: firstToken.y }
                     };
                 }
             }
         }
         
         // Step 2: Try first player-owned token in scene
         const playerToken = sceneData.tokens.find(t => t.is_player);
         if (playerToken) {
             console.log(`Spatial search: Using first player-owned token ${playerToken.name}`);
             return {
                 token_id: playerToken.id,
                 token_name: playerToken.name,
                 actor_id: playerToken.actor_id,
                 coordinates: { x: playerToken.x, y: playerToken.y }
             };
         }
         
         // Step 3: Try first non-player token in scene
         const anyToken = sceneData.tokens.find(t => !t.is_player);
         if (anyToken) {
             console.log(`Spatial search: Using first non-player token ${anyToken.name}`);
             return {
                 token_id: anyToken.id,
                 token_name: anyToken.name,
                 actor_id: anyToken.actor_id,
                 coordinates: { x: anyToken.x, y: anyToken.y }
             };
         }
         
         // Step 4: No tokens found
         console.log('Spatial search: No tokens in scene, skipping');
         return null;
     }
     ```
   - Modify `getFullWorldState()` to include spatial context when auto-search is enabled:
     ```javascript
     getFullWorldState() {
         // ... existing session_info, party_compendium, active_scene, compendium_index ...
         
         // Add spatial context if auto-search enabled
         const autoSearchEnabled = game.settings.get('the-gold-box', 'autoSearchEnabled');
         if (autoSearchEnabled) {
             const searchOrigin = this.getSpatialSearchOrigin(activeScene);
             if (searchOrigin) {
                 worldState.spatial_context = {
                     search_origin: searchOrigin,
                     enabled: true,
                     radius: game.settings.get('the-gold-box', 'autoSearchRadius', 6),
                     mode: game.settings.get('the-gold-box', 'autoSearchMode', 'line_of_sight')
                 };
             } else {
                 worldState.spatial_context = {
                     enabled: false,
                     reason: "No tokens available in scene"
                 };
             }
         } else {
             worldState.spatial_context = {
                 enabled: false,
                 reason: "Auto-search disabled in settings"
             };
         }
         
         return worldState;
     }
     ```
   - Spatial context is recalculated on each AI turn boundary via world state sync

11. **Add Distance Unit Parsing to Backend** (`backend/shared/startup/config.py` or `universal_settings.py`)
   - Add `grid_square_size` field to settings schema
   - Add `max_nearest_tokens` field to settings schema
   - Validate format (plain language: "5 feet", "2 meters")
   - Default to "5 feet"
   - Fallback to squares if invalid

12. **Add Shapely Dependency** (`backend/requirements.txt`)
   - Add `shapely>=2.0.0` to requirements
   - This enables wall shape detection

13. **Add Function Check Tests** (`function_check.sh`)
   - Test get_nearby_objects with token origin: `tool get_nearby_objects origin="<token_id>" radius=6 search_mode="line_of_sight"`
   - Test get_nearby_objects with coordinates: `tool get_nearby_objects origin='{"x":1000,"y":1500}' radius=6 search_mode="absolute"`
   - Test with different search modes
   - Verify distance units work (5 feet setting)
   - Verify fallback to squares with invalid setting
   - Verify token distances included
   - Verify line-of-sight filtering works
   - Verify distance matrix included (pairwise distances)
   - Test auto-search triggering from user's PC

### Acceptance Criteria

- [ ] AI can query nearby objects around a location or token
- [ ] Supports both absolute and line-of-sight search modes
- [ ] Wall filtering respects Foundry's vision-blocking rules (wall.sense)
- [ ] Distance reporting in user-configurable natural language units
- [ ] Fallback to squares if distance setting invalid
- [ ] Token distances pre-calculated and included in results
- [ ] Distance matrix for nearest 5 tokens with pairwise distances
- [ ] Journal notes exposed as-is (entry_name, journal_entry_title, note_type)
- [ ] Auto-search triggers based on user's configured PC token
- [ ] Results limited to prevent token overflow (max 30 objects total)
- [ ] No spatial summaries (deferred for AI performance testing)
- [ ] All tests in function_check.sh pass
- [ ] No console errors during spatial filtering

---

## Feature 2: Journal Context Search

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ get_journal_context(entry_name, search_phrase, context_lines) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                              â†“
Journal context data â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `get_journal_context` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "get_journal_context",
             "description": "Searches for a phrase within a journal entry and returns the surrounding context. Returns matching text with specified number of lines before and after for context. Similar to grep -C (context) but for journal content. Use after seeing a map note to get detailed information about that location.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "entry_name": {
                         "type": "string",
                         "description": "Name of the journal entry to search"
                     },
                     "search_phrase": {
                         "type": "string",
                         "description": "Phrase to search for within the journal entry"
                     },
                     "context_lines": {
                         "type": "integer",
                         "description": "Number of lines of context before and after the match (default: 3)",
                         "default": 3,
                         "minimum": 0,
                         "maximum": 20
                     }
                 },
                 "required": ["entry_name", "search_phrase"]
             }
         }
     }
     ```

2. **Implement `get_journal_context` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_journal_context()` method
   - Validate input parameters
   - Send journal context request to frontend via WebSocket
   - Include entry_name, search_phrase, and context_lines in request
   - Await journal context response (5 second timeout)
   - Format and return journal context to AI
   - Handle timeout and error cases (entry not found, etc.)

3. **Add Journal Context Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_JOURNAL_CONTEXT = "get_journal_context"` constant
   - Add `TYPE_JOURNAL_CONTEXT = "journal_context"` constant (for responses)
   - Document message formats in protocol specification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `getJournalContext(entry_name, search_phrase, context_lines)` method
   - Find journal entry by name:
     ```javascript
     const journalEntry = game.journal.find(entry => entry.name === entry_name);
     ```
   - If not found, return error: `{"success": false, "message": "Journal entry not found"}`
   - Get text content from first page:
     ```javascript
     const text = journalEntry.pages.contents[0]?.text?.content || '';
     ```
   - Split text into lines:
     ```javascript
     const lines = text.split('\n');
     ```
   - Search for phrase (case-insensitive):
     ```javascript
     const matches = [];
     lines.forEach((line, index) => {
         if (line.toLowerCase().includes(search_phrase.toLowerCase())) {
             const start = Math.max(0, index - context_lines);
             const end = Math.min(lines.length, index + context_lines + 1);
             matches.push({
                 match: line,
                 context: lines.slice(start, end),
                 line_number: index + 1,
                 position: {start, end}
             });
         }
     });
     ```
   - Return matches array with entry metadata:
     ```javascript
     {
         entry_name: journalEntry.name,
         entry_id: journalEntry.id,
         search_phrase: search_phrase,
         matches: matches,
         total_matches: matches.length
     }
     ```
   - Handle errors (entry not found, no matches)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_journal_context` messages
   - Route to WorldStateCollector
   - Send `journal_context` responses back to backend
   - Add error handling for journal context queries

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for get_journal_context: `tool get_journal_context entry_name="<name>" search_phrase="<phrase>"`
   - Add test with custom context_lines: `tool get_journal_context entry_name="<name>" search_phrase="<phrase>" context_lines=5`
   - Test case-insensitive search
   - Test entry not found error
   - Test no matches scenario
   - Verify context lines returned correctly

### Acceptance Criteria

- [x] AI can search journal entries for specific phrases
- [x] Search is case-insensitive
- [x] Context lines returned around matches
- [x] Multiple matches found in single entry
- [x] Works with large journal entries (e.g., Sunless Citadel)
- [x] No sub-section extraction (journal notes link to full entry, AI searches when needed)
- [x] Appropriate error messages for invalid entries
- [x] All tests in function_check.sh pass
- [x] No console errors during journal context queries

---

## Feature 3: Compendium Search

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ search_compendium(pack_name, query) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                  â†“
Compendium search results â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `search_compendium` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "search_compendium",
             "description": "Searches within a specific compendium pack for entries matching a query. Returns matching entries with their names, IDs, and key information. Use to find items, spells, monsters, or other game content in compendiums.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "pack_name": {
                         "type": "string",
                         "description": "Name of the compendium pack to search (e.g., 'dnd5e.items', 'dnd5e.spells', 'world.lore-journals')"
                     },
                     "query": {
                         "type": "string",
                         "description": "Search query text (case-insensitive, partial matches allowed)"
                     }
                 },
                 "required": ["pack_name", "query"]
             }
         }
     }
     ```

2. **Implement `search_compendium` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_search_compendium()` method
   - Validate input parameters
   - Send compendium search request to frontend via WebSocket
   - Include pack_name and query in request
   - Await compendium search response (5 second timeout)
   - Format and return compendium search results to AI
   - Handle timeout and error cases (pack not found, etc.)

3. **Add Compendium Search Message Types** (`message_protocol.py`)
   - Add `TYPE_SEARCH_COMPENDIUM = "search_compendium"` constant
   - Add `TYPE_COMPENDIUM_RESULTS = "compendium_results"` constant (for responses)
   - Document message formats in protocol specification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `searchCompendium(pack_name, query)` method
   - Find compendium pack:
     ```javascript
     const pack = game.packs.get(pack_name);
     ```
   - If not found, return error: `{"success": false, "message": "Compendium pack not found"}`
   - Get compendium index:
     ```javascript
     const index = await pack.getIndex();
     ```
   - Filter index for matches (case-insensitive):
     ```javascript
     const matches = index.filter(entry => 
         entry.name.toLowerCase().includes(query.toLowerCase())
     );
     ```
   - Get full documents for matches (limit to top 20):
     ```javascript
     const topMatches = matches.slice(0, 20);
     const documents = await pack.getDocuments(topMatches.map(m => m._id));
     ```
   - Format results:
     ```javascript
     documents.map(doc => ({
         id: doc.id,
         name: doc.name,
         type: doc.type,
         img: doc.img,
         // Add system-specific fields based on type
         system: {
             // For items: value, weight, etc.
             // For actors: hp, ac, etc.
             // For spells: level, school, etc.
         }
     }))
     ```
   - Return results with metadata:
     ```javascript
     {
         pack_name: pack_name,
         query: query,
         total_matches: matches.length,
         returned_matches: documents.length,
         results: formatted_documents
     }
     ```
   - Handle errors (pack not found, no matches)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `search_compendium` messages
   - Route to WorldStateCollector
   - Send `compendium_results` responses back to backend
   - Add error handling for compendium searches

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for search_compendium: `tool search_compendium pack_name="dnd5e.items" query="sword"`
   - Add test for spells: `tool search_compendium pack_name="dnd5e.spells" query="fireball"`
   - Add test for monsters: `tool search_compendium pack_name="dnd5e.monsters" query="goblin"`
   - Test case-insensitive search
   - Test pack not found error
   - Test no matches scenario
   - Verify results include relevant system data

### Acceptance Criteria

- [ ] AI can search compendium packs for entries
- [ ] Search is case-insensitive
- [ ] Results include key information (name, type, system data)
- [ ] Works with different pack types (items, spells, monsters, journals)
- [ ] Results limited to reasonable number (top 20)
- [ ] Appropriate error messages for invalid packs
- [ ] All tests in function_check.sh pass
- [ ] No console errors during compendium searches

---

## Feature 4: Party Member Tracking

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ get_party_members() â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                        â†“
Party members data â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `get_party_members` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with no parameters
   - Validate no parameters required
   - Add description: "Returns a list of all player-controlled characters (PCs) in the session. Includes character names, player names, and basic information for party composition awareness."

2. **Implement `get_party_members` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_party_members()` method
   - Send party members request to frontend via WebSocket
   - Await party members response (5 second timeout)
   - Format and return party members data to AI
   - Handle timeout and error cases

3. **Add Party Members Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_PARTY_MEMBERS = "get_party_members"` constant
   - Add `TYPE_PARTY_MEMBERS = "party_members"` constant (for responses)
   - Document message formats in protocol specification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `getPartyMembers()` method
   - Get all actors:
     ```javascript
     game.actors.filter(actor => actor.hasPlayerOwner)
     ```
   - Format results:
     ```javascript
     actors.map(actor => ({
         id: actor.id,
         name: actor.name,
         type: actor.type,
         img: actor.img,
         owners: actor.owners.map(owner => ({
             id: owner.id,
             name: game.users.get(owner.id)?.name || 'Unknown',
             is_active: owner.active
         })),
         system: {
             // Add basic system data
             hp: actor.system.attributes?.hp,
             ac: actor.system.attributes?.ac
         }
     }))
     ```
   - Return results:
     ```javascript
     {
         total_party_members: formatted_actors.length,
         members: formatted_actors
     }
     ```
   - Handle errors (no party members)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_party_members` messages
   - Route to WorldStateCollector
   - Send `party_members` responses back to backend
   - Add error handling for party member queries

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for get_party_members: `tool get_party_members`
   - Verify returns all player-owned characters
   - Verify includes owner information
   - Verify handles empty party

### Acceptance Criteria

- [ ] AI can query party member information
- [ ] Returns all player-owned characters
- [ ] Includes owner/player information
- [ ] Includes basic system data (HP, AC)
- [ ] Appropriate error messages for empty party
- [ ] All tests in function_check.sh pass
- [ ] No console errors during party member queries

---

## Feature 5: Enhanced Delta Tracking

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/message_services/message_delta_service.py` (new deltas)
- `backend/services/message_services/websocket_message_collector.py` (track new deltas)
- `scripts/api/combat-monitor.js` (transmit new deltas)
- `scripts/services/world-state-collector.js` (track scene deltas)
- `backend/testing/function_check.sh` (delta tests)

### Tasks

1. **Add SceneChanged Delta** (`message_delta_service.py`)
   - Add `SceneChanged` field to delta format
   - Structure:
     ```json
     {
       "new_scene_id": "string",
       "new_scene_name": "string"
     }
     ```
   - Clear after AI turn completes

2. **Add TokenMoved Delta** (`message_delta_service.py`)
   - Add `TokenMoved` field to delta format
   - Structure:
     ```json
     {
       "token_id": "string",
       "old_position": {"x": number, "y": number},
       "new_position": {"x": number, "y": number}
     }
     ```
   - Clear after AI turn completes

3. **Add SceneNoteUpdated Delta** (`message_delta_service.py`)
   - Add `SceneNoteUpdated` field to delta format
   - Structure:
     ```json
     {
       "note_id": "string",
       "entry_name": "string",
       "position": {"x": number, "y": number}
     }
     ```
   - Clear after AI turn completes

4. **Track Scene Changes in Frontend** (`world-state-collector.js`)
   - On `updateScene` hook (scene changes):
     - Set `SceneChanged` in delta with new scene ID and name
     - Send delta to backend via WebSocket

5. **Track Token Movements in Frontend** (`world-state-collector.js`)
   - On `updateToken` hook (token position changes):
     - Detect position changes
     - Track token_id, old_position, new_position
     - Set `TokenMoved` in delta with relevant data
     - Send delta to backend via WebSocket

6. **Track Note Updates in Frontend** (`world-state-collector.js`)
   - On `updateNote` hook (note changes):
     - Detect note updates
     - Track note_id, entry_name, position
     - Set `SceneNoteUpdated` in delta with relevant data
     - Send delta to backend via WebSocket

7. **Add Delta Tests** (`function_check.sh`)
   - Test SceneChanged delta after scene change
   - Test TokenMoved delta after token movement
   - Test SceneNoteUpdated delta after note update
   - Verify deltas cleared after AI turn

### Acceptance Criteria

- [ ] SceneChanged delta tracks scene changes
- [ ] TokenMoved delta tracks token position changes
- [ ] SceneNoteUpdated delta tracks note updates
- [ ] Deltas transmitted from frontend to backend
- [ ] Deltas included in AI context when changes occur
- [ ] Deltas cleared after AI turn completes
- [ ] Live testing confirms delta tracking working correctly

---

## Feature 6: Initial Context Expansion

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `scripts/services/world-state-collector.js` (enhance initial context)
- `backend/services/message_services/context_builder.py` (update context structure)

### Tasks

1. **Add Auto-Search to Initial Context** (`world-state-collector.js`)
   - Modify `getWorldStateOverview()` to include auto-search
   - Check if auto-search is enabled in settings
   - Get user's PC token from settings
   - Call `buildNearbyObjectsContext()` if PC token found
   - Add `nearby_scene_objects` to initial context

2. **Add compendium_index to World State** (`world-state-collector.js`)
   - Add `compendium_index` object to root of World State Overview:
     ```javascript
     {
         "pack_name": "dnd5e.monsters",
         "type": "Actor"
     }
     ```
   - Scan all available compendium packs:
     ```javascript
     game.packs.map(pack => ({
         pack_name: pack.collection,
         type: pack.metadata.type,
         entity: pack.metadata.entity
     }))
     ```
   - Include world and system compendiums

3. **Verify Context Structure and Add Spatial Context** (`context_builder.py`)
   - Ensure expanded World State Overview is properly formatted
   - Verify JSON structure matches expected schema
   - Test with real Foundry session data
   - Add spatial context from world state to initial context:
     ```python
     def build_initial_context(self, client_id: str) -> Dict[str, Any]:
         # ... existing code ...
         
         if world_state:
             # Add spatial context to initial context
             spatial_context = world_state.get("spatial_context", {})
             if spatial_context.get("enabled", False):
                 context["spatial_context"] = spatial_context
         
         return context
     ```

4. **Add Initial Context Tests** (`function_check.sh`)
   - Test that initial context includes nearby_scene_objects when auto-search enabled
   - Test that initial context includes compendium_index
   - Verify all required fields present
   - Test that auto-search respects user's PC token setting

### Acceptance Criteria

- [ ] Auto-search uses fallback chain: user's PC token â†’ first player-owned token â†’ first non-player token â†’ skip if no tokens
- [ ] Auto-search triggers based on Foundry's built-in user.character property (no custom setting needed)
- [ ] Initial context includes nearby_scene_objects when enabled
- [ ] Initial context includes compendium_index
- [ ] All compendium packs indexed
- [ ] Context structure validated
- [ ] All tests in function_check.sh pass

---

## Feature 7: Testing Infrastructure

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/testing/individual_tests/test_multi_command_and_deltas.sh` (enhanced test)
- `backend/testing/test_helpers.sh` (helper functions as needed)

### Overview

The enhanced `test_multi_command_and_deltas.sh` test will verify all new AI tools and spatial context functionality in a single integrated test. This replaces redundant message/dice roll tests with comprehensive tool testing across two AI turns.

### Test Structure

**Phase 1: First AI Turn - Initial Context & Tool Testing**
1. Start test session
2. Verify spatial context in initial world state
3. Execute batch of 4 new tool commands:
   - get_party_members
   - search_compendium
   - get_journal_context
   - get_nearby_objects (using spatial context token_id)
4. Verify each tool's results

**Phase 2: Manual Changes**
1. End session WITHOUT WebSocket reset (preserving client_id)
2. Wait for user to make manual changes in Foundry VTT

**Phase 3: Second AI Turn - Delta & Persistence**
1. Start new session (same client_id - subsequent turn)
2. Verify spatial context appears in subsequent turn (persistence)
3. Verify deltas captured from manual changes

### Tasks

#### 1. Enhance Test Script with New Tool Tests

**Add Spatial Context Verification (First AI Turn)**
```bash
# After starting session, verify spatial context in initial world state
test_command "Verify Initial Spatial Context" "status"

echo "ðŸ“Š SPATIAL CONTEXT VERIFICATION (First Turn):"
echo ""
echo "The initial_prompt above should include:"
echo "   â€¢ spatial_context object with search_origin details"
echo "   â€¢ search_origin should contain: token_id, token_name, actor_id, coordinates"
echo "   â€¢ enabled: true (if tokens in scene)"
echo "   â€¢ radius: from settings (default 6)"
echo "   â€¢ mode: from settings (default 'line_of_sight')"
echo ""

# Extract and display spatial context details
SPATIAL_ENABLED=$(get_value ".initial_messages[0].content | fromjson? // {} | .spatial_context.enabled // false")
SPATIAL_TOKEN_NAME=$(get_value ".initial_messages[0].content | fromjson? // {} | .spatial_context.search_origin.token_name // 'none'")
SPATIAL_TOKEN_ID=$(get_value ".initial_messages[0].content | fromjson? // {} | .spatial_context.search_origin.token_id // 'null'")

echo "ðŸ“ Spatial Context Status:"
echo "   â€¢ Enabled: $SPATIAL_ENABLED"
echo "   â€¢ Token Name: $SPATIAL_TOKEN_NAME"
echo "   â€¢ Token ID: $SPATIAL_TOKEN_ID"
echo ""

if [ "$SPATIAL_ENABLED" = "true" ]; then
  echo "âœ… VERIFICATION PASSED: Spatial context present in initial prompt"
  
  # Save token_id for later use in spatial search
  if [ "$SPATIAL_TOKEN_ID" != "null" ] && [ -n "$SPATIAL_TOKEN_ID" ]; then
    echo "$SPATIAL_TOKEN_ID" > .spatial_token_id
    echo "ðŸ’¾ Saved spatial search token_id: $SPATIAL_TOKEN_ID"
  fi
else
  echo "âš ï¸  WARNING: Spatial context not enabled (no tokens in scene or disabled in settings)"
fi
echo ""
```

**Add Tool Test Batch (Replace Redundant Tests)**
```bash
# Execute batch of 4 new tool commands (replaces redundant message/dice tests)
echo "â”â”â” Execute New Tool Test Batch â”â”â”"
echo ""
echo "Testing 4 new AI tools:"
echo "   1. get_party_members"
echo "   2. search_compendium"
echo "   3. get_journal_context"
echo "   4. get_nearby_objects"
echo ""

# Execute each tool in batch
test_command "Get Party Members" "get_party_members"
test_command "Search Compendium" "search_compendium pack_name=\"dnd5e.items\" query=\"sword\""

# Extract a journal entry name from world state for journal context test
JOURNAL_ENTRY_NAME=$(get_value ".initial_messages[0].content | fromjson? // {} | .active_scene.notes[0].journal_entry_title // 'Foundry Handbook'")
test_command "Get Journal Context" "get_journal_context entry_name=\"$JOURNAL_ENTRY_NAME\" search_phrase=\"interface\" context_lines=3"

# Use token from spatial context for spatial search
SPATIAL_TOKEN_ID=$(cat .spatial_token_id 2>/dev/null || echo "null")
if [ "$SPATIAL_TOKEN_ID" != "null" ] && [ -n "$SPATIAL_TOKEN_ID" ]; then
  test_command "Get Nearby Objects" "get_nearby_objects origin=\"$SPATIAL_TOKEN_ID\" radius=6 search_mode=line_of_sight"
else
  echo "âš ï¸  Skipping get_nearby_objects (no token_id from spatial context)"
fi
echo ""
```

**Add Party Members Verification**
```bash
echo "ðŸ“Š PARTY MEMBERS VERIFICATION:"
echo ""
echo "The party_members result should include:"
echo "   â€¢ total_party_members: count of player-owned characters"
echo "   â€¢ members: array with actor details (id, name, type, owners, system data)"
echo ""

PARTY_COUNT=$(get_value ".result.tool_results.get_party_members.total_party_members // 0")
echo "ðŸ“ Party Members Found: $PARTY_COUNT"

if [ $PARTY_COUNT -gt 0 ]; then
  # Extract first member details
  FIRST_MEMBER=$(get_value ".result.tool_results.get_party_members.members[0].name // 'unknown'")
  FIRST_MEMBER_ID=$(get_value ".result.tool_results.get_party_members.members[0].id // 'unknown'")
  echo "   â€¢ First member: $FIRST_MEMBER (ID: $FIRST_MEMBER_ID)"
  echo "âœ… VERIFICATION PASSED: Party members retrieved"
else
  echo "âš ï¸  WARNING: No party members found (scene may be empty)"
fi
echo ""
```

**Add Compendium Search Verification**
```bash
echo "ðŸ“Š COMPENDIUM SEARCH VERIFICATION:"
echo ""
echo "The compendium_results should include:"
echo "   â€¢ pack_name: compendium pack searched"
echo "   â€¢ query: search term used"
echo "   â€¢ total_matches: number of matching entries"
echo "   â€¢ results: array of matching items (id, name, type, system data)"
echo ""

COMPENDIUM_PACK=$(get_value ".result.tool_results.search_compendium.pack_name // 'none'")
TOTAL_MATCHES=$(get_value ".result.tool_results.search_compendium.total_matches // 0")
RETURNED_RESULTS=$(get_value ".result.tool_results.search_compendium.returned_matches // 0")

echo "ðŸ“ Compendium Search Results:"
echo "   â€¢ Pack: $COMPENDIUM_PACK"
echo "   â€¢ Total matches: $TOTAL_MATCHES"
echo "   â€¢ Returned results: $RETURNED_RESULTS"

if [ $TOTAL_MATCHES -gt 0 ]; then
  # Extract first match details
  FIRST_MATCH=$(get_value ".result.tool_results.search_compendium.results[0].name // 'unknown'")
  FIRST_MATCH_TYPE=$(get_value ".result.tool_results.search_compendium.results[0].type // 'unknown'")
  echo "   â€¢ First match: $FIRST_MATCH (Type: $FIRST_MATCH_TYPE)"
  echo "âœ… VERIFICATION PASSED: Compendium search successful"
else
  echo "âš ï¸  WARNING: No matches found (pack may not exist or no matching items)"
fi
echo ""
```

**Add Journal Context Verification**
```bash
echo "ðŸ“Š JOURNAL CONTEXT VERIFICATION:"
echo ""
echo "The journal_context result should include:"
echo "   â€¢ entry_name: name of journal entry searched"
echo "   â€¢ entry_id: Foundry ID of the entry"
echo "   â€¢ search_phrase: phrase searched for"
echo "   â€¢ matches: array of matching lines with context"
echo "   â€¢ total_matches: count of matches found"
echo ""

JOURNAL_ENTRY=$(get_value ".result.tool_results.get_journal_context.entry_name // 'none'")
TOTAL_MATCHES=$(get_value ".result.tool_results.get_journal_context.total_matches // 0")

echo "ðŸ“ Journal Context Results:"
echo "   â€¢ Entry: $JOURNAL_ENTRY"
echo "   â€¢ Total matches: $TOTAL_MATCHES"

if [ $TOTAL_MATCHES -gt 0 ]; then
  # Extract first match context
  FIRST_CONTEXT=$(get_value ".result.tool_results.get_journal_context.matches[0].match // 'none'")
  LINE_NUMBER=$(get_value ".result.tool_results.get_journal_context.matches[0].line_number // 0")
  echo "   â€¢ First match at line $LINE_NUMBER: $FIRST_CONTEXT"
  echo "âœ… VERIFICATION PASSED: Journal context retrieved"
else
  echo "âš ï¸  WARNING: No matches found (entry may not exist or phrase not found)"
fi
echo ""
```

**Add Spatial Search Verification**
```bash
echo "ðŸ“Š SPATIAL SEARCH VERIFICATION:"
echo ""
echo "The nearby_objects result should include:"
echo "   â€¢ nearby_scene_objects with grouped results"
echo "   â€¢ tokens, structures, locations_of_interest, lighting sections"
echo "   â€¢ distance_matrix for nearest 5 tokens"
echo "   â€¢ All objects within 6 grid units radius"
echo "   â€¢ Distances in user-configured units (default: 5 feet)"
echo ""

TOKEN_COUNT=$(get_value ".result.tool_results.get_nearby_objects.nearby_scene_objects.tokens.count // 0")
TOTAL_OBJECTS=$(get_value ".result.tool_results.get_nearby_objects.nearby_scene_objects.total_objects_found // 0")

echo "ðŸ“ Spatial Search Results:"
echo "   â€¢ Tokens found: $TOKEN_COUNT"
echo "   â€¢ Total objects: $TOTAL_OBJECTS"

if [ $TOTAL_OBJECTS -gt 0 ]; then
  # Extract distance matrix info
  MATRIX_TOKENS=$(get_value ".result.tool_results.get_nearby_objects.distance_matrix.total_tokens_in_scene // 0")
  echo "   â€¢ Distance matrix covers $MATRIX_TOKENS tokens"
  echo "âœ… VERIFICATION PASSED: Spatial search returned objects"
else
  echo "âš ï¸  WARNING: No objects found (scene may be empty)"
fi
echo ""
```

#### 2. Update Final Test Report

**Update Test Summary Section**
```bash
# Report final test result
report_test_result "New Tools & Spatial Context" \
  "get_party_members - retrieve player-owned characters" \
  "search_compendium - search compendium packs" \
  "get_journal_context - search journal entries" \
  "get_nearby_objects - spatial context search" \
  "Spatial context in initial world state" \
  "Spatial context persistence across AI turns" \
  "WebSocket preservation (no reset between sessions)"
```

**Update Manual Testing Instructions**
```bash
# In the pause section, update instructions
echo "ðŸŽ® INSTRUCTIONS FOR DELTA & PERSISTENCE TEST:"
echo ""
echo "Please make the following changes in Foundry VTT:"
echo "   â€¢ Create 1-2 new chat messages (type and press Enter)"
echo "   â€¢ (Optional) Move a token on the scene"
echo "   â€¢ (Optional) Start/End combat (Combat tab â†’ Start/End Combat)"
echo ""
echo "After making changes, press Enter to start new test session"
echo "   and verify:"
echo "   â€¢ Deltas captured from your changes"
echo "   â€¢ Spatial context still present in subsequent turn"
echo ""
```

**Add Spatial Context Persistence Verification (Second AI Turn)**
```bash
# After starting new session, verify spatial context persists
test_command "Verify Spatial Context in Second Turn" "status"

echo "ðŸ“Š SPATIAL CONTEXT VERIFICATION (Second Turn - Persistence):"
echo ""
echo "The initial_prompt above should include:"
echo "   â€¢ spatial_context object (may be same or updated from first turn)"
echo "   â€¢ Should reflect current state after manual changes"
echo "   â€¢ enabled: true (if tokens still in scene)"
echo ""

# Extract spatial context from second turn
SPATIAL_ENABLED_2=$(get_value ".initial_messages[0].content | fromjson? // {} | .spatial_context.enabled // false")
SPATIAL_TOKEN_NAME_2=$(get_value ".initial_messages[0].content | fromjson? // {} | .spatial_context.search_origin.token_name // 'none'")

echo "ðŸ“ Spatial Context Status (Second Turn):"
echo "   â€¢ Enabled: $SPATIAL_ENABLED_2"
echo "   â€¢ Token Name: $SPATIAL_TOKEN_NAME_2"
echo ""

if [ "$SPATIAL_ENABLED_2" = "true" ]; then
  echo "âœ… VERIFICATION PASSED: Spatial context persists across AI turns"
else
  echo "âš ï¸  WARNING: Spatial context not present in second turn"
fi
echo ""
```

#### 3. Update Test Helper Functions (if needed)

**Add Helper for JSON Parsing from Content**
```bash
# Add to test_helpers.sh if not present
# This helper extracts JSON from initial_messages content that contains embedded world state

# Example usage:
# get_value ".initial_messages[0].content | fromjson? // {} | .spatial_context.enabled // false"
```

### Pre-test Requirements

The enhanced test will require:
1. **Foundry VTT running** with a scene containing tokens
2. **Auto-search enabled** (default: true)
3. **At least one player-owned token** in scene (for party members and spatial context)
4. **At least one compendium pack** available (dnd5e or custom)
5. **At least one journal entry** in world (preferably with searchable text)
6. **Manual changes between turns** (create messages, roll dice, move tokens, etc.)

### Test Scenarios Covered

1. **Initial Context**: Verify spatial context appears on first AI turn
2. **Party Members**: Retrieve list of player-owned characters
3. **Compendium Search**: Search for items in compendium packs
4. **Journal Context**: Search within journal entries for specific phrases
5. **Spatial Search**: Query nearby objects around token
6. **Persistence**: Verify spatial context persists across AI turns
7. **Delta Tracking**: Verify manual changes captured in subsequent turn
8. **WebSocket Preservation**: Verify client_id preserved between sessions

### Acceptance Criteria

- [ ] All new tools tested individually
- [ ] Integration tests validate complete workflows
- [ ] All tests pass
- [ ] Test documentation complete

---

## Feature 8: Documentation

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `CHANGELOG.md` (update)
- `ROADMAP.md` (update)
- `USAGE.md` (update if needed)

### Tasks

1. **Update CHANGELOG.md**
   - Create new section `## [0.3.11] - 2026-01-XX`
   - Document new features:
     - Unified spatial filtering system with configurable distance units
     - Distance matrix for nearest 5 tokens with pairwise distances
     - Journal context search
     - Compendium search
     - Party member tracking
     - Enhanced delta tracking (scene changes, token movements, note updates)
     - Auto-search based on user's PC token
     - Initial context expansion (nearby_objects, compendium_index)
   - Document any breaking changes
   - Document any migration notes

2. **Update ROADMAP.md**
   - Mark Patch 0.3.11 items as complete
   - Update progress indicators
   - Note any deviations from original plan

3. **Update USAGE.md** (if needed)
   - Add examples of new tools
   - Add workflow examples for spatial awareness
   - Add examples for knowledge discovery
   - Document spatial settings configuration

### Acceptance Criteria

- [ ] All changes documented in CHANGELOG.md
- [ ] ROADMAP.md updated with completion status
- [ ] Tool documentation complete

---

## Implementation Order

Recommended implementation sequence based on dependencies:

1. **Feature 5: Enhanced Delta Tracking** (foundational - deltas need to be ready before features use them)
2. **Feature 1: Unified Spatial Filtering System** (core feature, most complex)
3. **Feature 2: Journal Context Search** (independent feature)
4. **Feature 3: Compendium Search** (independent feature)
5. **Feature 4: Party Member Tracking** (independent feature)
6. **Feature 6: Initial Context Expansion** (depends on Feature 1)
7. **Feature 7: Testing Infrastructure** (validation)
8. **Feature 8: Documentation** (finalization)

---

## Testing Checklist

Before merging to main:

### Function Check Tests
- [ ] get_nearby_objects returns structured spatial data
- [ ] get_nearby_objects respects absolute vs line-of-sight modes
- [ ] get_nearby_objects includes token distances in user-configured units
- [ ] Distance unit parsing works (5 feet, 2 meters, squares fallback)
- [ ] get_nearby_objects includes distance matrix for nearest 5 tokens
- [ ] get_journal_context returns matching context
- [ ] search_compendium returns relevant results
- [ ] get_party_members returns player-owned characters
- [ ] SceneChanged delta appears after scene change
- [ ] TokenMoved delta appears after token movement
- [ ] SceneNoteUpdated delta appears after note update

### Integration Tests
- [ ] Spatial awareness workflow (radius search with distances)
- [ ] Knowledge search workflow (compendium â†’ journal context)
- [ ] Party awareness workflow (party members â†’ actor details)
- [ ] Auto-search workflow (PC token trigger â†’ spatial context)
- [ ] Delta tracking throughout scene changes

### Manual Testing
- [ ] Module loads without errors
- [ ] AI can query nearby objects around locations
- [ ] AI can search journal entries
- [ ] AI can search compendium packs
- [ ] AI can get party member information
- [ ] Spatial settings UI works correctly
- [ ] Distance unit configuration works (5 feet, 2 meters, squares)
- [ ] Distance matrix configuration works (size 5 default)
- [ ] Auto-search triggers based on user's PC token
- [ ] Initial context includes nearby_scene_objects when enabled
- [ ] Deltas appear correctly between AI turns
- [ ] No console errors

---

## Branch Management

### Create Feature Branch
```bash
git checkout main
git pull origin main
git checkout -b feature/0.3.11-the-observer
```

### Commit Strategy
- Separate commits per feature for easier review
- Use descriptive commit messages with prefixes:
  - `feat:` for new features
  - `refactor:` for code refactoring
  - `fix:` for bug fixes
  - `docs:` for documentation

### Merge to Main
```bash
git checkout main
git merge feature/0.3.11-the-observer
git push origin main
```

### Tag Release
```bash
git tag v0.3.11
git push origin v0.3.11
```

---

## Release Notes

### New Features
- Unified spatial filtering system (`get_nearby_objects`) with radius-based searching
- Two search modes: absolute (all objects) and line-of-sight (visible only)
- User-configurable distance units (plain language: "5 feet", "2 meters", defaults to squares)
- Pre-calculated token distances included in spatial queries
- Distance matrix for nearest 5 tokens with pairwise distances (tokens only, configurable size)
- Journal context search for detailed information about map notes
- Compendium search for items, spells, monsters, etc.
- Party member tracking for party composition awareness
- Enhanced delta tracking for scene changes, token movements, note updates
- Auto-search triggering based on user's configured PC token
- Initial context expansion with nearby_objects and compendium_index

### Breaking Changes
- None

### Migration Notes
- No manual migration required for existing installations
- All features backward compatible
- Users should configure their PC token in settings for auto-search functionality
- Shapely dependency added for wall shape detection (future feature)

---

## Spatial Context Fallback Logic - Implementation Summary

### Overview
The automatic spatial context generation uses a robust fallback chain to ensure the AI always has spatial context when tokens are available in the scene. This eliminates the need for manual configuration while providing flexibility for different gameplay scenarios.

### Fallback Chain Priority
1. **User's Configured Player Character Token** (highest priority)
   - Uses Foundry's built-in `game.user.character` property
   - Finds all tokens for the user's configured PC in the current scene
   - Uses the first matching token if multiple exist
   
2. **First Player-Owned Token in Scene**
   - If user has no configured PC, or PC has no tokens in scene
   - Searches for any token with `is_player: true` flag
   - Uses the first player-owned token found
   
3. **First Non-Player Token in Scene**
   - If no player-owned tokens exist
   - Uses the first token regardless of ownership
   - Ensures spatial context is still provided (e.g., for NPC-focused games)
   
4. **Skip Spatial Context**
   - If no tokens exist in the scene at all
   - Or if auto-search is disabled in settings
   - Spatial context omitted from AI prompt

### Implementation Details

**Frontend (`world-state-collector.js`):**
- `getSpatialSearchOrigin(sceneData)` method implements the fallback chain
- Returns object with token_id, token_name, actor_id, and coordinates
- Returns null if no tokens found (graceful degradation)
- Console logging tracks which fallback level was used

**World State Integration (`getFullWorldState()`):**
- Checks `autoSearchEnabled` setting before attempting search
- Calls `getSpatialSearchOrigin()` to determine search origin
- Includes spatial_context object in world state with:
  - search_origin (token details and coordinates)
  - enabled (true/false)
  - radius (from settings)
  - mode (from settings)
  - reason (why disabled, if applicable)

**Backend Integration (`context_builder.py`):**
- Adds spatial_context to initial AI context if enabled
- AI receives spatial context at start of each turn
- AI can use `search_origin.token_id` or `search_origin.coordinates` to call `get_nearby_objects` tool

### Settings Configuration
Three settings control auto-search behavior:
- `autoSearchEnabled` (boolean, default: true) - Master on/off switch
- `autoSearchRadius` (number, default: 6) - Search radius in grid units
- `autoSearchMode` (enum, default: "line_of_sight") - Search mode

Note: No PC token setting needed - uses Foundry's built-in user configuration

### AI Tool Usage
When spatial context is available, the AI can:
- Use `get_nearby_objects` with `origin: search_origin.token_id` to search around the token
- Use `get_nearby_objects` with `origin: search_origin.coordinates` to search at specific coordinates
- Ignore the spatial context and search around a different location entirely

The spatial context provides a **suggested origin** but does not force AI behavior.

### Benefits
- **Zero configuration** - Uses Foundry's existing user.character setting
- **Graceful degradation** - Always works if tokens are present
- **Flexible** - Adapts to different game styles (PC-focused, NPC-focused, etc.)
- **Per-turn updates** - Recalculated on each AI turn boundary
- **AI-controlled** - AI decides whether and how to use the spatial context

---

**End of Implementation Plan**
