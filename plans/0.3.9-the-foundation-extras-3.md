# The Gold Box v0.3.9 - Extras #3: Minor Improvements and UI Polish

**Version:** 0.3.9-extras-3  
**Related Patch:** 0.3.9-the-foundation  
**Status:** Ready for Implementation  
**Date:** 2025-12-29

---

## Overview

This plan addresses several minor improvements identified during testing and user feedback:
1. Enhanced logger with automatic pretty-printing for JSON objects
2. User-friendly WebSocket authentication error messages
3. Settings menu reorganization with dropdown grouping
4. Complete AI Turn button state machine rewrite
5. Logging cleanup with selective preservation of critical information
6. Universal automatic WebSocket reconnection
7. Remove all emojis from the entire project

---

## Feature 1: Enhanced Logger with JSON Pretty-Printing

### Problem
Current logger outputs JSON objects as single-line strings, making them difficult to read in logs. Nested JSON objects are particularly hard to parse.

### Solution
Create a custom logging formatter that automatically detects and pretty-prints JSON objects with proper indentation.

### Files Modified
- `backend/shared/startup/startup.py` - Add custom JSON formatter
- `backend/shared/startup/config.py` - Update logging configuration

### Implementation Steps

1. **Create JSONPrettyFormatter class** in `backend/shared/startup/config.py`:
   ```python
   import logging
   import json
   
   class JSONPrettyFormatter(logging.Formatter):
       def format(self, record):
           message = super().format(record)
           # Try to detect and pretty-print JSON
           try:
               # Check if message contains JSON-like patterns
               if '{' in message and '}' in message:
                   # Extract and format JSON portions
                   lines = message.split('\n')
                   formatted_lines = []
                   for line in lines:
                       # Simple heuristic: if line starts with dict-like structure
                       if line.strip().startswith('{') or line.strip().startswith('['):
                           try:
                               parsed = json.loads(line.strip())
                               formatted_lines.append(json.dumps(parsed, indent=2, ensure_ascii=False))
                           except:
                               formatted_lines.append(line)
                       else:
                           formatted_lines.append(line)
                   message = '\n'.join(formatted_lines)
           except:
               pass
           return message
   ```

2. **Update logging configuration** to use the new formatter:
   ```python
   # Apply JSONPrettyFormatter to all handlers
   formatter = JSONPrettyFormatter(
       fmt='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
       datefmt='%Y-%m-%d %H:%M:%S'
   )
   
   for handler in logging.root.handlers:
       handler.setFormatter(formatter)
   ```

### Expected Outcome
- All JSON objects in logs are automatically pretty-printed with 2-space indentation
- Nested JSON structures are clearly readable
- No changes needed to existing logger calls

---

## Feature 2: User-Friendly WebSocket Authentication Errors

### Problem
When WebSocket connection fails due to missing password or auth token, users see generic error messages without guidance on how to fix the issue.

### Solution
Detect authentication failures and provide clear, actionable error messages directing users to Foundry settings.

### Files Modified
- `backend/services/system_services/websocket_handler.py`

### Implementation Steps

1. **Detect authentication errors** in WebSocket connection:
   ```python
   async def handle_websocket_connection(self, websocket: WebSocket):
       try:
           # Accept connection
           await websocket.accept()
           
           # Verify token/password
           await self.verify_authentication(websocket)
           
       except HTTPException as e:
           if e.status_code in [401, 403]:
               # Send user-friendly error message
               error_message = {
                   'type': 'error',
                   'data': {
                       'error': 'Authentication failed',
                       'message': 'Please set your backend server password in The Gold Box settings. Navigate to Configure Settings -> The Gold Box -> Backend Password.',
                       'code': 'AUTH_REQUIRED'
                   }
               }
               await websocket.send_json(error_message)
               await websocket.close(code=1008, reason='Authentication required')
               logger.warning(f"WebSocket authentication failed for client: {e.detail}")
               return
           raise
   ```

2. **Update frontend error handling** in `scripts/api/websocket-client.js`:
   ```javascript
   handleError(error) {
     console.error('WebSocket error:', error);
     this.isConnected = false;
     this.stopPingInterval();
     
     // Check if it's an authentication error
     if (error.data?.code === 'AUTH_REQUIRED') {
       this.onError?.(error.data.message);
     } else {
       this.onError?.(error);
     }
   }
   ```

3. **Display user-friendly notification** in `scripts/gold-box.js`:
   ```javascript
   onWebSocketError(error) {
     if (error.includes('Please set your backend server password')) {
       ui.notifications?.error(error, {permanent: true});
     } else {
       ui.notifications?.error('WebSocket connection failed: ' + error);
     }
   }
   ```

### Expected Outcome
- Authentication failures show clear, actionable error messages
- Users know exactly where to configure the backend password
- Generic errors still show for other connection issues

---

## Feature 3: Settings Menu Reorganization

### Problem
The settings menu lists all LLM settings (general and tactical) together, making it long and difficult to navigate.

### Solution
Add a dropdown selector to show/hide General or Tactical settings groups.

### Files Modified
- `scripts/gold-box.js` - Settings registration and UI
- `module.json` - Settings structure

### Implementation Steps

1. **Add settings group selector** in `module.json`:
   ```json
   {
     "name": "settingsGroup",
     "scope": "client",
     "config": true,
     "default": "general",
     "type": "Select",
     "choices": {
       "general": "General Settings",
       "tactical": "Tactical Settings"
     },
     "label": "Settings Group",
     "hint": "Choose which group of settings to display"
   }
   ```

2. **Group settings by category** in `module.json`:
   - Add `"group": "general"` to: temperature, maxTokens, topP, frequencyPenalty, presencePenalty, etc.
   - Add `"group": "tactical"` to: combatRole, autoRollDice, combatDescriptionStyle, etc.

3. **Implement show/hide logic** in `scripts/gold-box.js`:
   ```javascript
   // Watch for settings group changes
   Hooks.on('renderSettings', (app, html, data) => {
     const settingsGroup = game.settings.get('the-gold-box', 'settingsGroup');
     
     // Find all setting rows
     html.find('.form-group').each(function() {
       const settingName = $(this).data('setting');
       const settingData = game.settings.settings.get('the-gold-box.' + settingName);
       
       if (settingData && settingData.group) {
         if (settingData.group !== settingsGroup) {
           $(this).hide();
         } else {
           $(this).show();
         }
       }
     });
   });
   ```

4. **Add change listener** for settings group:
   ```javascript
   // Re-render settings when group changes
   game.settings.register('the-gold-box', 'settingsGroup', {
     name: 'Settings Group',
     scope: 'client',
     config: true,
     default: 'general',
     type: String,
     choices: {
       'general': 'General Settings',
       'tactical': 'Tactical Settings'
     },
     onChange: (value) => {
       // Trigger settings UI refresh
       ui.settings?.render(true);
     }
   });
   ```

### Expected Outcome
- Settings menu shows dropdown at top to select General or Tactical group
- Only settings from selected group are visible
- Settings without a group are always visible
- Dropdown preserves selection across sessions

---

## Feature 4: AI Turn Button State Machine Rewrite

### Problem
AI Turn button lacks proper state management, doesn't update at correct times, and has inconsistent visual states.

### Solution
Create a dedicated `AITurnButtonHandler` class with a proper state machine that manages button appearance and behavior.

### Files Modified
- `scripts/shared/ui-manager.js` - Add AITurnButtonHandler class
- `scripts/gold-box.js` - Integrate with state machine

### Implementation Steps

1. **Create AITurnButtonHandler class** in `scripts/shared/ui-manager.js`:
   ```javascript
   class AITurnButtonHandler {
     constructor(uiManager, moduleInstance) {
       this.uiManager = uiManager;
       this.moduleInstance = moduleInstance;
       this.state = 'DISCONNECTED'; // States: DISCONNECTED, CONNECTED, THINKING
       this.button = null;
       this.ellipsisIndex = 0;
       this.ellipsisInterval = null;
     }
     
     // State transitions
     setState(newState) {
       const oldState = this.state;
       this.state = newState;
       console.log(`AI Turn Button: ${oldState} -> ${newState}`);
       this.updateButton();
     }
     
     // Update button appearance based on state
     updateButton() {
       if (!this.button) {
         this.button = $('#gold-box-ai-turn-btn');
       }
       
       if (!this.button.length) return;
       
       switch (this.state) {
         case 'DISCONNECTED':
           this.setDisconnectedState();
           break;
         case 'CONNECTED':
           this.setConnectedState();
           break;
         case 'THINKING':
           this.setThinkingState();
           break;
       }
     }
     
     setDisconnectedState() {
       this.button.css({
         'background': '#808080',
         'color': '#ffffff',
         'opacity': '0.5',
         'cursor': 'not-allowed'
       });
       this.button.text('Not Connected');
       this.button.prop('disabled', true);
       this.stopEllipsisAnimation();
     }
     
     setConnectedState() {
       this.button.css({
         'background': 'linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FF8C00 100%)',
         'color': '#1a1a1a',
         'opacity': '1',
         'cursor': 'pointer'
       });
       this.button.text('Take AI Turn');
       this.button.prop('disabled', false);
       this.stopEllipsisAnimation();
     }
     
     setThinkingState() {
       this.button.css({
         'background': 'linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FF8C00 100%)',
         'color': '#1a1a1a',
         'opacity': '0.5',
         'cursor': 'not-allowed'
       });
       this.button.prop('disabled', true);
       this.startEllipsisAnimation();
     }
     
     startEllipsisAnimation() {
       this.stopEllipsisAnimation();
       this.ellipsisIndex = 0;
       this.updateEllipsis();
       this.ellipsisInterval = setInterval(() => {
         this.updateEllipsis();
       }, 500);
     }
     
     updateEllipsis() {
       const ellipsis = '.'.repeat((this.ellipsisIndex % 3) + 1);
       this.button.text('Thinking' + ellipsis);
       this.ellipsisIndex++;
     }
     
     stopEllipsisAnimation() {
       if (this.ellipsisInterval) {
         clearInterval(this.ellipsisInterval);
         this.ellipsisInterval = null;
       }
     }
     
     // Event handlers
     onWebSocketConnected() {
       this.setState('CONNECTED');
     }
     
     onWebSocketDisconnected() {
       this.setState('DISCONNECTED');
     }
     
     onAITurnStarted() {
       this.setState('THINKING');
     }
     
     onAITurnEnded() {
       this.setState('CONNECTED');
     }
     
     onAITurnError(error) {
       console.error('AI Turn error:', error);
       this.setState('CONNECTED');
     }
     
     destroy() {
       this.stopEllipsisAnimation();
       this.button = null;
     }
   }
   ```

2. **Integrate with GoldBox class** in `scripts/gold-box.js`:
   ```javascript
   // In constructor
   this.aiTurnButtonHandler = new AITurnButtonHandler(this.uiManager, this);
   
   // Update WebSocket connection handlers
   async handleWebSocketConnection() {
     try {
       await this.websocket.connect();
       this.aiTurnButtonHandler.onWebSocketConnected();
     } catch (error) {
       this.aiTurnButtonHandler.onWebSocketDisconnected();
       throw error;
     }
   }
   
   // Update AI turn flow
   async onTakeAITurn() {
     this.aiTurnButtonHandler.onAITurnStarted();
     
     try {
       // ... existing AI turn logic ...
       await this.processAITurn();
       this.aiTurnButtonHandler.onAITurnEnded();
     } catch (error) {
       this.aiTurnButtonHandler.onAITurnError(error);
       throw error;
     }
   }
   ```

3. **Update connection manager** to notify button handler:
   ```javascript
   // In scripts/api/connection-manager.js
   onConnect() {
     window.goldBox?.aiTurnButtonHandler?.onWebSocketConnected();
   }
   
   onDisconnect() {
     window.goldBox?.aiTurnButtonHandler?.onWebSocketDisconnected();
   }
   ```

### Expected Outcome
- Button has 3 clear states: Grey ("Not Connected"), Gold ("Take AI Turn"), Semi-transparent Gold with animated "Thinking..."
- State transitions occur at correct times: connect/disconnect, turn start/end/error
- Ellipsis animation cycles: "Thinking." -> "Thinking.." -> "Thinking..." (repeats every 1.5s)
- Proper state machine prevents invalid transitions

---

## Feature 5: Selective Logging Cleanup

### Problem
Logs are overly verbose with routine operations, making it difficult to find important information.

### Solution
Remove verbose logging while preserving critical information blocks for debugging and monitoring.

### Files Modified
- `backend/services/ai_services/ai_orchestrator.py`
- `backend/services/ai_tools/ai_tool_executor.py`
- `backend/services/message_services/websocket_message_collector.py`
- `backend/services/system_services/websocket_handler.py`

### Logging Preservation Rules

**KEEP (INFO level):**
1. AI Conversation Messages:
   - `"===== SENDING INITIAL MESSAGES TO AI ====="` through `"===== END SENDING INITIAL MESSAGES ====="`
   - `"===== ADDING MESSAGE TO CONVERSATION ====="` through `"===== END ADDING MESSAGE ====="`
   - `"===== SENDING TO AI ====="` through `"===== END SENDING TO AI ====="`
   - `"===== RECEIVED FROM AI ====="` through `"===== END RECEIVED FROM AI ====="`

2. Endpoint Reports:
   - `INFO: ::1:44276 - "GET /api/health HTTP/1.1" 200 OK`
   - All HTTP request/response logs from Uvicorn

3. Outbound Connection Updates:
   - `03:45:08 - LiteLLM:INFO: utils.py:3427 - LiteLLM completion() model= glm-4.7; provider = openai`
   - All LiteLLM provider connection logs

4. WebSocket Connection Status:
   - Connection established/closed messages
   - Client connected/disconnected messages

5. Critical Errors:
   - All ERROR and WARNING level logs

**REMOVE or MOVE TO DEBUG:**
- `"Tools available to AI: 4 tools"` and tool listing
- `"WebSocket: [FAST PATH] Handling X for client Y"` routine routing messages
- `"WebSocket: [SLOW PATH] Creating background task for X"`
- `"Game delta stored for client X"` (keep only if hasChanges=True)
- `"Delta hasChanges: False - no changes to report"`
- `"Session: ai_session_XXX"` (keep only in ADD MESSAGE blocks)
- `"Role: assistant/tool/user"` (keep only in ADD MESSAGE blocks)
- Roll result processing steps (6+ lines, consolidate to 2-3)
- Combat state double logging

### Implementation Steps

1. **Clean up ai_orchestrator.py**:
   ```python
   # REMOVE:
   logger.info(f"Tools available to AI: {len(tools)} tools")
   # for tool in tools:
   #     logger.info(f"  - {tool['function']['name']}")
   
   # KEEP all "=====" blocks
   logger.info("===== SENDING INITIAL MESSAGES TO AI =====")
   logger.info(f"Complete initial_messages array:\n{json.dumps(initial_messages, indent=2)}")
   logger.info("===== END SENDING INITIAL MESSAGES =====")
   ```

2. **Clean up websocket_message_collector.py**:
   ```python
   # REMOVE duplicate logging
   # logger.info(f"Combat state stored for client {client_id}: in_combat={in_combat}")
   # Keep only:
   logger.info(f"Updated combat state for client {client_id}: in_combat={in_combat}")
   
   # REMOVE routing messages
   # logger.info(f"WebSocket: [FAST PATH] Handling {msg_type} for client {client_id}")
   # logger.info(f"WebSocket: [SLOW PATH] Creating background task for {msg_type}")
   ```

3. **Consolidate roll result logging** in ai_tool_executor.py:
   ```python
   # REDUCE from 6+ lines to 2:
   logger.info(f"Received roll_result for request {request_id} with {len(results['results'])} results")
   logger.info(f"Roll results: {json.dumps(results, indent=2)}")
   # Move all internal processing to DEBUG level
   ```

4. **Remove no-changes delta logging**:
   ```python
   # REMOVE:
   # logger.info("Delta hasChanges: False - no changes to report")
   # KEEP only:
   if hasChanges:
       logger.info(f"Game delta stored for client {client_id}: hasChanges=True")
   ```

### Expected Outcome
- Logs are significantly cleaner while preserving all critical debugging information
- AI conversation flow remains fully traceable
- Connection status and health checks still visible
- 70% reduction in log volume for routine operations

---

## Feature 6: Universal Automatic WebSocket Reconnection

### Problem
WebSocket connections can be lost due to network issues, but current reconnection logic is not universally applied and has limited retry attempts.

### Solution
Implement a robust reconnection mechanism that automatically attempts 3 reconnections with exponential backoff when WebSocket is lost.

### Files Modified
- `scripts/api/websocket-client.js`

### Implementation Steps

1. **Enhance reconnection logic** in websocket-client.js:
   ```javascript
   class GoldBoxWebSocketClient {
     constructor(baseUrl, onMessage, onError) {
       // ... existing code ...
       this.reconnectAttempts = 0;
       this.maxReconnectAttempts = 3; // Changed from 5 to 3
       this.reconnectDelay = 1000;
       this.reconnectTimer = null;
       this.isReconnecting = false;
     }
     
     handleClose(event) {
       console.log('WebSocket connection closed:', event.code, event.reason);
       this.isConnected = false;
       this.stopPingInterval();
       
       // Clear pending requests
       for (const [requestId, resolver] of this.pendingRequests) {
         resolver({success: false, error: 'Connection closed'});
       }
       this.pendingRequests.clear();
       
       // Notify button handler
       if (window.goldBox?.aiTurnButtonHandler) {
         window.goldBox.aiTurnButtonHandler.onWebSocketDisconnected();
       }
       
       // Attempt reconnection (always, regardless of close code)
       if (this.reconnectAttempts < this.maxReconnectAttempts) {
         this.scheduleReconnect();
       } else {
         console.error('WebSocket reconnection failed after 3 attempts');
         ui.notifications?.error('WebSocket connection lost after 3 reconnection attempts. Please refresh the page.', {permanent: true});
       }
     }
     
     scheduleReconnect() {
       if (this.reconnectTimer) {
         clearTimeout(this.reconnectTimer);
       }
       
       this.reconnectAttempts++;
       this.isReconnecting = true;
       
       // Exponential backoff: 1s, 2s, 4s
       const delay = Math.min(4000, this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1));
       
       console.log(`Scheduling WebSocket reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
       ui.notifications?.info(`WebSocket reconnecting in ${delay/1000}s... (attempt ${this.reconnectAttempts}/3)`);
       
       this.reconnectTimer = setTimeout(async () => {
         this.reconnectTimer = null;
         try {
           console.log('Attempting WebSocket reconnect...');
           await this.connect();
           this.reconnectAttempts = 0; // Reset on success
           this.isReconnecting = false;
           console.log('WebSocket reconnected successfully');
           ui.notifications?.success('WebSocket reconnected successfully');
         } catch (error) {
           console.error('WebSocket reconnection failed:', error);
           if (this.reconnectAttempts < this.maxReconnectAttempts) {
             this.scheduleReconnect();
           }
         }
       }, delay);
     }
     
     // Override connect to reset reconnect attempts on manual connect
     async connect() {
       try {
         if (this.isConnected && !this.isReconnecting) {
           console.warn('WebSocket already connected');
           return true;
         }
         
         // Reset reconnect attempts for manual connections
         if (!this.isReconnecting) {
           this.reconnectAttempts = 0;
         }
         
         // ... existing connection logic ...
         
       } catch (error) {
         console.error('Error creating WebSocket connection:', error);
         this.onError?.(error);
         return false;
       }
     }
   }
   ```

2. **Add error resilience** for AI turn during reconnection:
   ```javascript
   // In gold-box.js
   async onTakeAITurn() {
     if (!this.websocket?.isConnected && !this.websocket?.isReconnecting) {
       ui.notifications?.error('Cannot take AI turn: WebSocket not connected');
       return;
     }
     
     // If reconnecting, wait for connection
     if (this.websocket?.isReconnecting) {
       ui.notifications?.info('Waiting for WebSocket reconnection...');
       await this.websocket.waitForConnection(10000); // 10s timeout
     }
     
     // ... rest of AI turn logic ...
   }
   ```

### Expected Outcome
- WebSocket automatically reconnects up to 3 times on connection loss
- Exponential backoff: 1s, 2s, 4s delays between attempts
- Clear user notifications about reconnection status
- AI turn waits for reconnection if in progress
- Graceful failure after 3 attempts with user notification

---

## Feature 7: Remove All Emojis from Project

### Problem
Emojis are used throughout the project for visual appeal but may not align with all user preferences or accessibility requirements.

### Solution
Remove all emoji characters from the entire codebase.

### Files Modified
- All `.js` files in `scripts/` directory
- All `.py` files in `backend/` directory
- `README.md`
- `CHANGELOG.md`
- All markdown files in `plans/` directory

### Implementation Steps

1. **Search and remove emojis** using find/replace:
   - Search common emoji patterns and replace with plain text or remove
   - Examples:
     - "âœ…" â†’ remove or replace with "OK" / "Success"
     - "âš ï¸" â†’ remove or replace with "WARNING"
     - "ðŸ”’" â†’ remove or replace with "Locked"
     - "ðŸŽ²" â†’ remove or replace with "Dice"
     - "ðŸ’¬" â†’ remove or replace with "Chat"
     - "ðŸ“‹" â†’ remove or replace with "List"
     - "ðŸ›¡ï¸" â†’ remove or replace with "Shield"

2. **Update UI notifications** to use text instead of emojis:
   ```javascript
   // Before:
   ui.notifications?.success('âœ… Connected to backend');
   
   // After:
   ui.notifications?.success('Connected to backend');
   ```

3. **Update chat messages** to remove emojis:
   ```javascript
   // Before:
   '<p>âœ… Connection successful</p>'
   
   // After:
   '<p>Connection successful</p>'
   ```

4. **Update documentation** to remove emojis from examples and descriptions

### Verification Steps
1. Search for common emoji Unicode ranges:
   ```bash
   grep -r "[\x{1F300}-\x{1F9FF}]" scripts/ backend/ --include="*.js" --include="*.py"
   ```
2. Review all user-facing text for emoji usage
3. Test all notifications and UI messages

### Expected Outcome
- Zero emojis in the codebase
- All text remains clear and readable
- No loss of functionality or clarity
- Improved accessibility for screen readers

---

## Implementation Order

1. **Feature 7: Remove emojis** (foundational - affects all files)
2. **Feature 1: Enhanced logger** (backend-only, isolated)
3. **Feature 2: Auth error messages** (backend + frontend integration)
4. **Feature 6: Auto-reconnect** (WebSocket logic)
5. **Feature 4: AI Turn button state machine** (requires WebSocket integration)
6. **Feature 5: Logging cleanup** (dependent on logger changes)
7. **Feature 3: Settings dropdown** (UI-only, final polish)

---

## Testing Checklist

### Feature 1: Enhanced Logger
- [ ] Verify JSON objects are pretty-printed in logs
- [ ] Check nested JSON structures are readable
- [ ] Confirm no breaking changes to existing log format

### Feature 2: Auth Error Messages
- [ ] Test WebSocket connection without password
- [ ] Verify user-friendly error message appears
- [ ] Confirm error message directs to Foundry settings
- [ ] Test connection with valid password works normally

### Feature 3: Settings Dropdown
- [ ] Verify dropdown appears in settings menu
- [ ] Test switching between General and Tactical groups
- [ ] Confirm only relevant settings are shown
- [ ] Verify setting changes persist across page refresh

### Feature 4: AI Turn Button State Machine
- [ ] Verify button shows "Not Connected" when WebSocket disconnected
- [ ] Verify button shows "Take AI Turn" when WebSocket connected
- [ ] Verify button shows "Thinking..." with ellipsis animation during AI turn
- [ ] Test state transitions on connect/disconnect
- [ ] Test state transitions on turn start/end/error
- [ ] Verify ellipsis animation cycles correctly (1, 2, 3 dots)

### Feature 5: Logging Cleanup
- [ ] Verify critical AI conversation blocks are preserved
- [ ] Verify endpoint reports are preserved
- [ ] Verify outbound connection logs are preserved
- [ ] Confirm verbose routine logging is removed
- [ ] Check log volume reduction (target: ~70% reduction)

### Feature 6: Auto-Reconnect
- [ ] Test automatic reconnection on connection loss
- [ ] Verify 3 reconnection attempts with exponential backoff
- [ ] Confirm user notifications show reconnection status
- [ ] Test graceful failure after 3 attempts
- [ ] Verify AI turn waits for reconnection if in progress

### Feature 7: Remove Emojis
- [ ] Search codebase for remaining emojis
- [ ] Verify all notifications use plain text
- [ ] Check all chat messages for emoji removal
- [ ] Review documentation for emoji removal
- [ ] Test UI readability without emojis

---

## Success Criteria

- [ ] All JSON logs are automatically pretty-printed
- [ ] Authentication errors show clear, actionable messages
- [ ] Settings menu has dropdown with General/Tactical groups
- [ ] AI Turn button has 3 states with correct transitions
- [ ] Ellipsis animation cycles: "Thinking." -> "Thinking.." -> "Thinking..."
- [ ] Log volume reduced by ~70% while preserving critical info
- [ ] WebSocket auto-reconnects 3 times with exponential backoff
- [ ] Zero emojis remain in the codebase
- [ ] All function check tests pass
- [ ] No console errors or warnings
- [ ] UI remains responsive and user-friendly

---

## Notes

- Feature 7 (emoji removal) should be done first as it affects all files
- Logging cleanup must preserve all "=====" blocks as specified by user
- Button state machine should use existing gold gradient with opacity changes
- Ellipsis animation timing: 500ms per dot change (1.5s full cycle)
- Reconnection attempts: exactly 3, not 5
- All changes must maintain backward compatibility
- No new dependencies required

---

**End of Plan**
