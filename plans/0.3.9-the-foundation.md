# Implementation Plan: Patch 0.3.9 - The Foundation

**Version:** 0.3.9  
**Branch:** `feature/0.3.9-the-foundation`  
**Status:** Planning Phase  
**Goal:** Establish AI's core ability to communicate, perceive basic game state, and interact with fundamental mechanics (dice, combat status)

---

## Overview

Patch 0.3.9 implements the foundational AI tools as outlined in ROADMAP.md. This patch focuses on core communication, perception, and basic combat status tracking. The implementation follows the feature branch model outlined in CONTRIBUTING.md.

### Key Deliverables

1. **Tool Naming Alignment** - Rename existing tools to match roadmap specification
2. **Dice Rolling** - Full two-way communication for AI-driven dice rolls
3. **Combat Status** - Leverage existing CombatMonitor for encounter tracking
4. **Enhanced Delta Tracking** - Smart filtering and no-changes detection
5. **Initial Context System** - First turn vs. successive turn context logic
6. **Testing Infrastructure** - Enhanced function checks and integration testing

---

## Feature 1: Tool Naming Alignment

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py`
- `backend/services/ai_tools/ai_tool_executor.py`
- `backend/services/ai_services/ai_orchestrator.py`
- `backend/api/api_chat.py`

### Tasks

1. **Rename Tool Definitions** (`ai_tool_definitions.py`)
   - [x] Rename `get_messages` → `get_message_history`
   - [x] Rename `post_messages` → `post_message`
   - [x] Update tool descriptions to match ROADMAP.md specifications
   - [x] Verify parameter schemas remain unchanged

2. **Update Tool Executor** (`ai_tool_executor.py`)
   - [x] Rename `execute_get_messages()` → `execute_get_message_history()`
   - [x] Rename `execute_post_messages()` → `execute_post_message()`
   - [x] Update method calls in `execute_tool()` routing
   - [x] Verify error messages use new function names

3. **Update AI Orchestrator** (`ai_orchestrator.py`)
   - [x] Search and replace all occurrences of `get_messages` with `get_message_history`
   - [x] Search and replace all occurrences of `post_messages` with `post_message`
   - [x] Update any logging that references tool names
   - [x] Verify conversation history logging uses correct names

4. **Update API Chat Endpoint** (`api_chat.py`)
   - [x] Update any hardcoded tool name references
   - [x] Update error messages if they reference tool names
   - [x] Verify tool validation logic uses new names

### Acceptance Criteria

- [x] All tool references use new names
- [x] No functional changes to tool behavior
- [x] Backward compatibility maintained where possible
- [x] Logging clearly indicates new tool names

---

## Feature 2: Dice Rolling Infrastructure

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `scripts/services/dice-roll-executor.js` (new service)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI → roll_dice(formula) → Backend → WebSocket → Frontend → Foundry API
                                                       ↓
Roll result ← Backend ← WebSocket ← Frontend ← Foundry executes
```

### Tasks

1. **Leverage Existing Roll Detection**
   - [x] Review existing roll identification in message processor
   - [x] Confirm dice roll message type detection works correctly
   - [x] Document roll message format for future reference

2. **Implement `roll_dice` Tool Definition** (`ai_tool_definitions.py`)
   - [x] Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "roll_dice",
             "description": "Roll one or more Foundry-formatted dice formulas",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "rolls": {
                         "type": "array",
                         "items": {
                             "type": "object",
                             "properties": {
                                 "formula": {"type": "string"},
                                 "flavor": {"type": "string"}
                             }
                         },
                         "required": ["formula"]
                     }
                 },
                 "required": ["rolls"]
             }
         }
     }
     ```
   - [x] Validate parameter schemas
   - [x] Add example usage in comments

3. **Implement `roll_dice` Tool Executor** (`ai_tool_executor.py`)
   - [x] Add `execute_roll_dice()` method
   - [x] Validate input parameters
   - [x] Send roll request to frontend via WebSocket
   - [x] Await roll result from frontend
   - [x] Format and return result to AI
   - [x] Handle timeout and error cases

4. **Create Frontend Dice Roll Executor** (`scripts/services/dice-roll-executor.js`)
   - [x] Create new DiceRollExecutor class
   - [x] Register WebSocket message handler for `execute_roll`
   - [x] Implement roll execution using Foundry's native API
   - [x] Capture roll result including:
     - Formula
     - Total result
     - Individual dice results (if applicable)
     - Flavor text
     - Timestamp
   - [x] Send result back to backend via WebSocket (`roll_result` message type)
   - [x] Handle roll errors (invalid formula, etc.)

5. **Add WebSocket Message Types** (`message_protocol.py`)
   - [x] Add `TYPE_EXECUTE_ROLL = "execute_roll"`
   - [x] Add `TYPE_ROLL_RESULT = "roll_result"`
   - [x] Document message formats in protocol specification

6. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - [x] Add handler for incoming `execute_roll` messages
   - [x] Route to DiceRollExecutor
   - [x] Send `roll_result` responses back to backend
   - [x] Add error handling for roll failures

7. **Add Function Check Tests** (`function_check.sh`)
   - [x] Add test for single dice roll: `tool roll_dice rolls=[{"formula": "1d20+5", "flavor": "Attack"}]`
   - [x] Add test for multiple rolls: `tool roll_dice rolls=[{"formula": "2d6"}, {"formula": "1d8+3"}]`
   - [x] Add test for roll without flavor: `tool roll_dice rolls=[{"formula": "1d20"}]`
   - [x] Verify roll results are displayed correctly
   - [x] Verify errors for invalid formulas

### Acceptance Criteria

- [x] AI can request dice rolls with formulas and flavor text
- [x] Frontend executes rolls using Foundry's native API
- [x] Roll results are returned to AI in correct format
- [x] Multiple rolls can be executed in single tool call
- [x] Error handling for invalid formulas
- [x] All tests in function_check.sh pass
- [x] No console errors during roll execution

---

## Feature 3: Combat Status Infrastructure

**Priority:** High  
**Complexity:** Low (leverage existing CombatMonitor)  
**Files Affected:**
- `scripts/api/combat-monitor.js` (enhance)
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/services/message_services/websocket_message_collector.py` (combat data)
- `scripts/api/websocket-client.js` (data transmission)
- `scripts/api/websocket-communicator.js` (initialization fixes)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
Foundry Combat Events → CombatMonitor → WebSocket → Backend → Cache
                                                            ↓
AI → get_encounter() → Backend → Request Fresh State → Frontend → 
                                                          Transmit State → 
                                                            ↓
                                                        Cached Combat State → Return to AI
```

**Design Principles:**
1. **Initial State Capture**: CombatMonitor captures state on module load if combat already active
2. **Automatic Updates**: All combat events trigger immediate state transmission
3. **Fresh State on Request**: get_encounter() requests fresh state from frontend (not periodic polling)
4. **Synchronized**: State always matches what's shown to players, no anticipation or lag

### Tasks

1. **Add Initial State Capture** (`combat-monitor.js`)
   - [x] Review existing CombatMonitor implementation
   - [x] Confirm combat state transmission via WebSocket
   - [x] Confirm automatic transmission on combat state changes
   - [x] Add initial state capture in CombatMonitor initialization
     - On `Hooks.once('ready')`, check if `game.combat` exists
     - If combat active, call `updateCombatState()` to capture and transmit initial state
   - [x] Verify combat start/end events are captured

2. **Implement `get_encounter` Tool Definition** (`ai_tool_definitions.py`)
   - [x] Add tool definition with no parameters
   - [x] Validate no parameters required

3. **Implement `get_encounter` Tool Executor** (`ai_tool_executor.py`)
   - [x] Add `execute_get_encounter()` method
   - [x] Get client_id from session context
   - [x] Send `combat_state_refresh` request to frontend via WebSocket
   - [x] Wait for `combat_state` response (2 second timeout)
   - [x] Query cached combat state from message collector
   - [x] If no active combat or timeout, return: `{"in_combat": false, "message": "No active encounter"}`
   - [x] If active combat, return full combat state with timestamp

4. **Add Combat State Message Type** (`message_protocol.py`)
   - [x] Add `TYPE_COMBAT_STATE = "combat_state"` constant
   - [x] Add `TYPE_COMBAT_STATE_REFRESH = "combat_state_refresh"` constant
   - [x] Document message formats in protocol specification

5. **Add Combat State Refresh Handler** (`websocket-communicator.js`)
   - [x] Add message handler for `combat_state_refresh` type
   - [x] Call `CombatMonitor.transmitCombatState()` to send fresh state
   - [x] Handle transmission errors

6. **Add Function Check Tests** (`function_check.sh`)
   - [x] Add test for get_encounter out of combat: `tool get_encounter`
   - [x] Add test for get_encounter in combat (start combat in Foundry)
   - [x] Add test for get_encounter after combat events (advance turn, add/remove combatant)
   - [x] Verify combat state format matches roadmap
   - [x] Verify "no active encounter" response when out of combat
   - [x] Verify state refresh works when called repeatedly

7. **Fix Turn Detection Issues** (`combat-monitor.js`)
   - [x] Replace `combatObj.turns` with `combatObj.setupTurns()` for proper initiative ordering
   - [x] Add `createCombatant` hook to handle new combatants
   - [x] Add `deleteCombatant` hook to handle removed combatants
   - [x] Ensure turn order updates on all combat state changes

### Bug Fixes: Initialization Stability

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `scripts/api/websocket-communicator.js`
- `scripts/api/websocket-client.js`

**Issues Fixed:**
1. **Health Check Timeout on Slow Systems** - The 2-second timeout for HTTP health checks was too aggressive for slow development laptops, causing "user aborted" errors even when the backend returned 200 OK
2. **WebSocket Using Hardcoded Port** - WebSocket connection always used port 5000 regardless of which port the backend was discovered on (5000, 5001, or 5002), causing connection failures
3. **Race Condition in Initialization** - Multiple simultaneous initialization attempts could conflict, causing the initialization process to fail or restart indefinitely

**Tasks**
- [x] Increase health check timeout from 2 seconds to 5 seconds in `discoverBackendPort()`
- [x] Add `isInitializing` flag to prevent concurrent initialization attempts
- [x] Update WebSocket URL construction to use discovered port instead of hardcoded 5000
- [x] Add `finally` block to ensure `isInitializing` flag is always reset

**Code Changes:**
```javascript
// websocket-communicator.js - Increased timeout
signal: AbortSignal.timeout(5000) // Increased from 2000ms to handle slow systems

// websocket-communicator.js - Added initialization guard
this.isInitializing = false;
// In _performInitialization():
if (this.isInitializing) {
  return this.initPromise;
}
this.isInitializing = true;
// ... finally { this.isInitializing = false; }

// websocket-client.js - Use discovered port
const wsUrl = this.baseUrl.replace('http://', 'ws://').replace('https://', 'wss://') + '/ws';
// Previously: const wsUrl = `ws://${url.hostname}:5000/ws`;
```

### Acceptance Criteria

- [x] Health check timeout increased to 5 seconds
- [x] Race condition guard prevents concurrent initialization
- [x] WebSocket uses correct port from health check discovery
- [x] Combat state is automatically transmitted from frontend to backend
- [x] AI can query current combat state
- [x] Returns appropriate response when no combat is active
- [x] Returns full combat data when combat is active
- [x] Combat state updates are reflected in subsequent queries
- [x] All tests in function_check.sh pass
- [x] No console errors during combat monitoring

---

## Feature 4: Enhanced Delta Tracking

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/message_services/message_delta_service.py` (enhance)
- `backend/services/message_services/websocket_message_collector.py` (roll tracking)
- `backend/services/ai_services/ai_orchestrator.py` (delta injection)
- `scripts/services/frontend-delta-service.js` (enhance)

### Tasks

1. **Update Delta Format to Match ROADMAP** (`message_delta_service.py`)
   - [ ] Ensure delta object uses exact field names from ROADMAP.md:
     ```json
     {
         "NewMessages": 2,
         "DeletedMessages": 0,
         "NewDiceRolls": [...],
         "EncounterStarted": {...},
         "EncounterEnded": true
     }
     ```
   - [ ] Update all delta field names to match roadmap
   - [ ] Maintain backward compatibility during transition

2. **Implement Smart Delta Filtering**
   - [ ] Add method to filter out zero/null delta fields
   - [ ] Skip: `"NewMessages": 0`, `"DeletedMessages": 0`, `"NewDiceRolls": []`
   - [ ] Skip: `"EncounterStarted": null`, `"EncounterEnded": null`
   - [ ] Only include fields with actual changes
   - [ ] Document delta filtering behavior

3. **Add No-Changes Detection**
   - [ ] Add `has_changes` flag to delta object
   - [ ] Set `has_changes: true` if any delta field has data
   - [ ] Set `has_changes: false` if all fields are zero/null/empty
   - [ ] When `has_changes: false`, include message: "No changes to game state since last AI turn"
   - [ ] Update AI Orchestrator to check this flag

4. **Extend Delta Service for Dice Rolls**
   - [ ] Add tracking for `NewDiceRolls` array
   - [ ] Capture dice rolls from message collector
   - [ ] Store roll data: `{"formula": "...", "result": ..., "flavor": "..."}`
   - [ ] Clear roll deltas when AI turn completes

5. **Extend Delta Service for Combat Events**
   - [ ] Add tracking for `EncounterStarted` object
   - [ ] Capture combat start with combat data
   - [ ] Add tracking for `EncounterEnded` boolean
   - [ ] Detect combat start/end from WebSocket collector
   - [ ] Clear combat deltas when AI turn completes

6. **Update WebSocket Message Collector**
   - [ ] Identify dice roll messages for delta counting
   - [ ] Extract roll data (formula, result, flavor)
   - [ ] Identify combat start events
   - [ ] Identify combat end events
   - [ ] Store deltas in Message Delta Service

7. **Update AI Orchestrator**
   - [ ] Check `has_changes` flag before sending deltas
   - [ ] If `has_changes: false`, send clear message to AI
   - [ ] Format delta section for AI prompt
   - [ ] Reset deltas after AI turn completes

### Acceptance Criteria

- [ ] Delta format exactly matches ROADMAP.md specification
- [ ] Only non-zero/non-null fields appear in delta output
- [ ] `has_changes` flag correctly indicates no-change scenarios
- [ ] `NewDiceRolls` captures all dice rolls since last AI turn
- [ ] `EncounterStarted` and `EncounterEnded` track combat events
- [ ] No console errors during delta tracking

---

## Feature 5: Initial Context System

**Priority:** High  
**Complexity:** High  
**Files Affected:**
- `backend/services/message_services/context_builder.py` (new service)
- `backend/services/ai_services/ai_session_manager.py` (track first turn)
- `backend/services/ai_services/ai_orchestrator.py` (context selection)
- `backend/services/system_services/service_factory.py` (register)
- `backend/shared/startup/services.py` (initialize)

### Architecture

- **First AI turn** (per client ID): Full initial context, no deltas
- **Successive AI turns** (same client ID): Deltas only, no full context
- Mutual exclusivity enforced

### Tasks

1. **Create Context Builder Service** (`context_builder.py`)
   - [ ] Create `ContextBuilder` class
   - [ ] Implement `build_initial_context(client_id)` method
   - [ ] Gather `session_info`:
     - game_system (from Foundry)
     - gm_name
     - players list
   - [ ] Gather `party_compendium`:
     - List all player-controlled characters
     - Include actor IDs and player names
   - [ ] Gather `active_scene`:
     - Scene ID
     - Scene name
     - Dimensions (width, height, grid)
     - Token list (id, name, actor_id, x, y, is_player)
   - [ ] Gather `active_encounter`:
     - Full combat data if active
     - `null` if no active combat
   - [ ] Return context object per ROADMAP.md specification

2. **Track First Turn Per Client** (`ai_session_manager.py`)
   - [ ] Add `has_first_turn_complete` flag to session data
   - [ ] Set flag to `false` on new session creation
   - [ ] Set flag to `true` after first AI turn completes
   - [ ] Add method to check first turn status

3. **Implement Context Selection Logic** (`ai_orchestrator.py`)
   - [ ] Check if session has completed first turn
   - [ ] **If first turn**:
     - Call `build_initial_context(client_id)`
     - Include full context in system prompt
     - Skip delta section entirely
     - Add section header: "World State Overview"
   - [ ] **If successive turn**:
     - Call delta service for recent changes
     - Include delta section only
     - Skip full initial context
     - Add section header: "Recent changes to the game"
   - [ ] Enforce mutual exclusivity (never both full context AND deltas)

4. **Register Context Builder Service** (`service_factory.py`)
   - [ ] Add `get_context_builder()` factory function
   - [ ] Register ContextBuilder in ServiceRegistry
   - [ ] Update service lifecycle management

5. **Initialize Context Builder** (`services.py`)
   - [ ] Import ContextBuilder
   - [ ] Register in startup sequence
   - [ ] Verify initialization succeeds

### Acceptance Criteria

- [ ] First AI turn receives full initial context
- [ ] Successive AI turns receive only deltas
- [ ] Context format matches ROADMAP.md specification
- [ ] Mutual exclusivity enforced (never both)
- [ ] Context builder successfully gathers all required data
- [ ] No console errors during context building

---

## Feature 6: Testing Infrastructure

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/testing/function_check.sh` (enhance)
- `backend/services/ai_services/testing_harness.py` (verify scope)
- `backend/testing/TESTING.md` (document limits)

### Tasks

1. **Limit Testing Harness Scope**
   - [ ] Verify testing harness ONLY simulates AI service
   - [ ] Ensure testing harness sends commands, receives responses AI would receive
   - [ ] NO feature implementation in testing harness
   - [ ] All features must be in actual server code
   - [ ] Document testing harness limitations in TESTING.md

2. **Enhance Function Check Script** (`function_check.sh`)
   - [ ] Add test for renamed tool `get_message_history`
   - [ ] Add test for renamed tool `post_message`
   - [ ] Add tests for `roll_dice`:
     - Single roll: `tool roll_dice rolls=[{"formula": "1d20+5", "flavor": "Attack"}]`
     - Multiple rolls: `tool roll_dice rolls=[{"formula": "2d6"}, {"formula": "1d8+3"}]`
     - Roll without flavor: `tool roll_dice rolls=[{"formula": "1d20"}]`
   - [ ] Add tests for `get_encounter`:
     - Out of combat: `tool get_encounter`
     - In combat: Start combat, then `tool get_encounter`
   - [ ] Display all return values for user confirmation
   - [ ] Add delta output verification tests
   - [ ] Add initial context verification tests
   - [ ] Add "no changes" scenario test

3. **Create Integration Test Plan**
   - [ ] Document full AI turn workflow test
   - [ ] Verify first turn uses full context
   - [ ] Verify successive turns use deltas
   - [ ] Verify no-changes detection works
   - [ ] End-to-end dice roll workflow test
   - [ ] Combat state monitoring verification test
   - [ ] Wait for user approval before all-up test

### Acceptance Criteria

- [ ] Function check tests all new tools
- [ ] All return values displayed for user confirmation
- [ ] Testing harness only simulates AI, no implementation
- [ ] Integration test plan documented
- [ ] All tests pass before proceeding to AI integration

---

## Feature 7: Documentation

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `CHANGELOG.md`
- `ROADMAP.md`
- `USAGE.md` (if needed)
- `backend/testing/TESTING.md` (testing limits)

### Tasks

1. **Update Tool Documentation**
   - [ ] Document all tool name changes
   - [ ] Update parameter descriptions for new tools
   - [ ] Add examples for `roll_dice`
   - [ ] Add examples for `get_encounter`
   - [ ] Document delta format changes
   - [ ] Document first-turn vs successive-turn context logic

2. **Update CHANGELOG.md**
   - [ ] Create new section `## [0.3.9] - YYYY-MM-DD`
   - [ ] Document breaking changes (tool renames)
   - [ ] Document new features:
     - Tool naming alignment
     - Dice rolling infrastructure
     - Combat status infrastructure
     - Enhanced delta tracking
     - Initial context system
   - [ ] Document delta format changes
   - [ ] Include migration notes if needed

3. **Update ROADMAP.md**
   - [ ] Mark Patch 0.3.9 items as complete
   - [ ] Update progress indicators
   - [ ] Note any deviations from original plan

4. **Document Testing Limitations** (`TESTING.md`)
   - [ ] Clarify testing harness scope
   - [ ] Document what testing harness does NOT do
   - [ ] Explain difference between testing harness and actual AI

### Acceptance Criteria

- [ ] All changes documented in CHANGELOG.md
- [ ] ROADMAP.md updated with completion status
- [ ] Tool documentation complete
- [ ] Testing limitations clearly documented

---

## Implementation Order

Recommended implementation sequence based on dependencies:

1. **Feature 1: Tool Naming Alignment** (foundation for all other features)
2. **Feature 4: Enhanced Delta Tracking** (data layer)
3. **Feature 5: Initial Context System** (data layer)
4. **Feature 2: Dice Rolling Infrastructure** (feature implementation)
5. **Feature 3: Combat Status Infrastructure** (feature implementation)
6. **Feature 6: Testing Infrastructure** (validation)
7. **Feature 7: Documentation** (finalization)

---

## Testing Checklist

Before merging to main:

### Function Check Tests
- [ ] `get_message_history` returns correct data
- [ ] `post_message` sends messages correctly
- [ ] `roll_dice` executes rolls and returns results
- [ ] `get_encounter` returns combat state or no-encounter response
- [ ] Delta output displays correctly
- [ ] Initial context displays correctly on first turn

### Integration Tests
- [ ] Full AI turn with actual AI service
- [ ] First turn uses full initial context
- [ ] Successive turns use deltas only
- [ ] No-changes detection works correctly
- [ ] Dice roll executes in Foundry and result returns to AI
- [ ] Combat state updates reflected in AI responses
- [ ] Tool renames don't break existing functionality

### Manual Testing
- [ ] Module loads without errors
- [ ] Settings menu opens correctly
- [ ] Backend connection works
- [ ] AI chat works with new tools
- [ ] Dice rolls execute in Foundry chat
- [ ] Combat state updates when combat starts/ends
- [ ] Deltas display correctly in logs
- [ ] No console errors in browser

---

## Branch Management

### Create Feature Branch
```bash
git checkout main
git pull origin main
git checkout -b feature/0.3.9-the-foundation
```

### Commit Strategy
- Separate commits per feature for easier review
- Use descriptive commit messages with prefixes:
  - `feat:` for new features
  - `refactor:` for code refactoring
  - `fix:` for bug fixes
  - `docs:` for documentation

### Merge to Main
```bash
git checkout main
git merge feature/0.3.9-the-foundation
git push origin main
```

### Tag Release
```bash
git tag v0.3.9
git push origin v0.3.9
```

---

## Release Notes

### Breaking Changes
- Tool names renamed: `get_messages` → `get_message_history`, `post_messages` → `post_message`
- Delta format updated to match ROADMAP.md specification

### New Features
- AI can execute dice rolls in Foundry
- AI can query current combat encounter state
- Smart delta filtering (zero/null values omitted)
- No-changes detection for efficient AI context
- First-turn vs successive-turn context logic

### Migration Notes
- No manual migration required for existing installations
- Tool names updated automatically
- Context switching handled automatically

---

**End of Implementation Plan**
