# Implementation Plan: Patch 0.3.9 - The Foundation

**Version:** 0.3.9  
**Branch:** `feature/0.3.9-the-foundation`  
**Status:** Planning Phase  
**Goal:** Establish AI's core ability to communicate, perceive basic game state, and interact with fundamental mechanics (dice, combat status)

---

## Overview

Patch 0.3.9 implements the foundational AI tools as outlined in ROADMAP.md. This patch focuses on core communication, perception, and basic combat status tracking. The implementation follows the feature branch model outlined in CONTRIBUTING.md.

### Key Deliverables

1. **Tool Naming Alignment** - Rename existing tools to match roadmap specification
2. **Dice Rolling** - Full two-way communication for AI-driven dice rolls
3. **Combat Status** - Leverage existing CombatMonitor for encounter tracking
4. **Enhanced Delta Tracking** - Smart filtering and no-changes detection
5. **Initial Context System** - First turn vs. successive turn context logic
6. **Testing Infrastructure** - Enhanced function checks and integration testing

---

## Feature 1: Tool Naming Alignment

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py`
- `backend/services/ai_tools/ai_tool_executor.py`
- `backend/services/ai_services/ai_orchestrator.py`
- `backend/api/api_chat.py`

### Tasks

1. **Rename Tool Definitions** (`ai_tool_definitions.py`)
   - [x] Rename `get_messages` → `get_message_history`
   - [x] Rename `post_messages` → `post_message`
   - [x] Update tool descriptions to match ROADMAP.md specifications
   - [x] Verify parameter schemas remain unchanged

2. **Update Tool Executor** (`ai_tool_executor.py`)
   - [x] Rename `execute_get_messages()` → `execute_get_message_history()`
   - [x] Rename `execute_post_messages()` → `execute_post_message()`
   - [x] Update method calls in `execute_tool()` routing
   - [x] Verify error messages use new function names

3. **Update AI Orchestrator** (`ai_orchestrator.py`)
   - [x] Search and replace all occurrences of `get_messages` with `get_message_history`
   - [x] Search and replace all occurrences of `post_messages` with `post_message`
   - [x] Update any logging that references tool names
   - [x] Verify conversation history logging uses correct names

4. **Update API Chat Endpoint** (`api_chat.py`)
   - [x] Update any hardcoded tool name references
   - [x] Update error messages if they reference tool names
   - [x] Verify tool validation logic uses new names

### Acceptance Criteria

- [x] All tool references use new names
- [x] No functional changes to tool behavior
- [x] Backward compatibility maintained where possible
- [x] Logging clearly indicates new tool names

---

## Feature 2: Dice Rolling Infrastructure

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `scripts/services/dice-roll-executor.js` (new service)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI → roll_dice(formula) → Backend → WebSocket → Frontend → Foundry API
                                                       ↓
Roll result ← Backend ← WebSocket ← Frontend ← Foundry executes
```

### Tasks

1. **Leverage Existing Roll Detection**
   - [x] Review existing roll identification in message processor
   - [x] Confirm dice roll message type detection works correctly
   - [x] Document roll message format for future reference

2. **Implement `roll_dice` Tool Definition** (`ai_tool_definitions.py`)
   - [x] Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "roll_dice",
             "description": "Roll one or more Foundry-formatted dice formulas",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "rolls": {
                         "type": "array",
                         "items": {
                             "type": "object",
                             "properties": {
                                 "formula": {"type": "string"},
                                 "flavor": {"type": "string"}
                             }
                         },
                         "required": ["formula"]
                     }
                 },
                 "required": ["rolls"]
             }
         }
     }
     ```
   - [x] Validate parameter schemas
   - [x] Add example usage in comments

3. **Implement `roll_dice` Tool Executor** (`ai_tool_executor.py`)
   - [x] Add `execute_roll_dice()` method
   - [x] Validate input parameters
   - [x] Send roll request to frontend via WebSocket
   - [x] Await roll result from frontend
   - [x] Format and return result to AI
   - [x] Handle timeout and error cases

4. **Create Frontend Dice Roll Executor** (`scripts/services/dice-roll-executor.js`)
   - [x] Create new DiceRollExecutor class
   - [x] Register WebSocket message handler for `execute_roll`
   - [x] Implement roll execution using Foundry's native API
   - [x] Capture roll result including:
     - Formula
     - Total result
     - Individual dice results (if applicable)
     - Flavor text
     - Timestamp
   - [x] Send result back to backend via WebSocket (`roll_result` message type)
   - [x] Handle roll errors (invalid formula, etc.)

5. **Add WebSocket Message Types** (`message_protocol.py`)
   - [x] Add `TYPE_EXECUTE_ROLL = "execute_roll"`
   - [x] Add `TYPE_ROLL_RESULT = "roll_result"`
   - [x] Document message formats in protocol specification

6. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - [x] Add handler for incoming `execute_roll` messages
   - [x] Route to DiceRollExecutor
   - [x] Send `roll_result` responses back to backend
   - [x] Add error handling for roll failures

7. **Add Function Check Tests** (`function_check.sh`)
   - [x] Add test for single dice roll: `tool roll_dice rolls=[{"formula": "1d20+5", "flavor": "Attack"}]`
   - [x] Add test for multiple rolls: `tool roll_dice rolls=[{"formula": "2d6"}, {"formula": "1d8+3"}]`
   - [x] Add test for roll without flavor: `tool roll_dice rolls=[{"formula": "1d20"}]`
   - [x] Verify roll results are displayed correctly
   - [x] Verify errors for invalid formulas

### Acceptance Criteria

- [x] AI can request dice rolls with formulas and flavor text
- [x] Frontend executes rolls using Foundry's native API
- [x] Roll results are returned to AI in correct format
- [x] Multiple rolls can be executed in single tool call
- [x] Error handling for invalid formulas
- [x] All tests in function_check.sh pass
- [x] No console errors during roll execution

---

## Feature 3: Combat Status Infrastructure

**Priority:** High  
**Complexity:** Low (leverage existing CombatMonitor)  
**Files Affected:**
- `scripts/api/combat-monitor.js` (enhance)
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/services/message_services/websocket_message_collector.py` (combat data)
- `scripts/api/websocket-client.js` (data transmission)
- `scripts/api/websocket-communicator.js` (initialization fixes)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
Foundry Combat Events → CombatMonitor → WebSocket → Backend → Cache
                                                            ↓
AI → get_encounter() → Backend → Request Fresh State → Frontend → 
                                                          Transmit State → 
                                                            ↓
                                                        Cached Combat State → Return to AI
```

**Design Principles:**
1. **Initial State Capture**: CombatMonitor captures state on module load if combat already active
2. **Automatic Updates**: All combat events trigger immediate state transmission
3. **Fresh State on Request**: get_encounter() requests fresh state from frontend (not periodic polling)
4. **Synchronized**: State always matches what's shown to players, no anticipation or lag

### Tasks

1. **Add Initial State Capture** (`combat-monitor.js`)
   - [x] Review existing CombatMonitor implementation
   - [x] Confirm combat state transmission via WebSocket
   - [x] Confirm automatic transmission on combat state changes
   - [x] Add initial state capture in CombatMonitor initialization
     - On `Hooks.once('ready')`, check if `game.combat` exists
     - If combat active, call `updateCombatState()` to capture and transmit initial state
   - [x] Verify combat start/end events are captured

2. **Implement `get_encounter` Tool Definition** (`ai_tool_definitions.py`)
   - [x] Add tool definition with no parameters
   - [x] Validate no parameters required

3. **Implement `get_encounter` Tool Executor** (`ai_tool_executor.py`)
   - [x] Add `execute_get_encounter()` method
   - [x] Get client_id from session context
   - [x] Send `combat_state_refresh` request to frontend via WebSocket
   - [x] Wait for `combat_state` response (2 second timeout)
   - [x] Query cached combat state from message collector
   - [x] If no active combat or timeout, return: `{"in_combat": false, "message": "No active encounter"}`
   - [x] If active combat, return full combat state with timestamp

4. **Add Combat State Message Type** (`message_protocol.py`)
   - [x] Add `TYPE_COMBAT_STATE = "combat_state"` constant
   - [x] Add `TYPE_COMBAT_STATE_REFRESH = "combat_state_refresh"` constant
   - [x] Document message formats in protocol specification

5. **Add Combat State Refresh Handler** (`websocket-communicator.js`)
   - [x] Add message handler for `combat_state_refresh` type
   - [x] Call `CombatMonitor.transmitCombatState()` to send fresh state
   - [x] Handle transmission errors

6. **Add Function Check Tests** (`function_check.sh`)
   - [x] Add test for get_encounter out of combat: `tool get_encounter`
   - [x] Add test for get_encounter in combat (start combat in Foundry)
   - [x] Add test for get_encounter after combat events (advance turn, add/remove combatant)
   - [x] Verify combat state format matches roadmap
   - [x] Verify "no active encounter" response when out of combat
   - [x] Verify state refresh works when called repeatedly

7. **Fix Turn Detection Issues** (`combat-monitor.js`)
   - [x] Replace `combatObj.turns` with `combatObj.setupTurns()` for proper initiative ordering
   - [x] Add `createCombatant` hook to handle new combatants
   - [x] Add `deleteCombatant` hook to handle removed combatants
   - [x] Ensure turn order updates on all combat state changes

### Bug Fixes: Initialization Stability

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `scripts/api/websocket-communicator.js`
- `scripts/api/websocket-client.js`

**Issues Fixed:**
1. **Health Check Timeout on Slow Systems** - The 2-second timeout for HTTP health checks was too aggressive for slow development laptops, causing "user aborted" errors even when the backend returned 200 OK
2. **WebSocket Using Hardcoded Port** - WebSocket connection always used port 5000 regardless of which port the backend was discovered on (5000, 5001, or 5002), causing connection failures
3. **Race Condition in Initialization** - Multiple simultaneous initialization attempts could conflict, causing the initialization process to fail or restart indefinitely

**Tasks**
- [x] Increase health check timeout from 2 seconds to 5 seconds in `discoverBackendPort()`
- [x] Add `isInitializing` flag to prevent concurrent initialization attempts
- [x] Update WebSocket URL construction to use discovered port instead of hardcoded 5000
- [x] Add `finally` block to ensure `isInitializing` flag is always reset

**Code Changes:**
```javascript
// websocket-communicator.js - Increased timeout
signal: AbortSignal.timeout(5000) // Increased from 2000ms to handle slow systems

// websocket-communicator.js - Added initialization guard
this.isInitializing = false;
// In _performInitialization():
if (this.isInitializing) {
  return this.initPromise;
}
this.isInitializing = true;
// ... finally { this.isInitializing = false; }

// websocket-client.js - Use discovered port
const wsUrl = this.baseUrl.replace('http://', 'ws://').replace('https://', 'wss://') + '/ws';
// Previously: const wsUrl = `ws://${url.hostname}:5000/ws`;
```

### Acceptance Criteria

- [x] Health check timeout increased to 5 seconds
- [x] Race condition guard prevents concurrent initialization
- [x] WebSocket uses correct port from health check discovery
- [x] Combat state is automatically transmitted from frontend to backend
- [x] AI can query current combat state
- [x] Returns appropriate response when no combat is active
- [x] Returns full combat data when combat is active
- [x] Combat state updates are reflected in subsequent queries
- [x] All tests in function_check.sh pass
- [x] No console errors during combat monitoring

---

## Feature 4: Enhanced Delta Tracking

**Priority:** High  
**Complexity:** Medium  
**Status:** ✅ COMPLETED  
**Files Affected:**
- `backend/services/message_services/message_delta_service.py` (already exists)
- `backend/services/message_services/websocket_message_collector.py` (roll tracking)
- `backend/services/ai_services/ai_orchestrator.py` (delta injection)
- `backend/shared/utils/ai_prompt_builder.py` (new shared utility) ✅
- `backend/api/api_chat.py` (use shared utility) ✅
- `backend/services/ai_services/testing_harness.py` (use shared utility) ✅
- `backend/api/admin.py` (fix testing harness delta retrieval) ✅
- `backend/testing/function_check.sh` (delta tests validated) ✅

**Implementation Notes:**
- Delta format uses existing structure with `hasChanges` flag
- Shared utility ensures consistent delta injection across AI service and testing harness
- Testing harness now properly retrieves delta using async polling
- Stale delta from previous sessions is cleared before new tests start
- No format changes needed - existing format works correctly

### Tasks

1. **Update Delta Format to Match ROADMAP** (`message_delta_service.py`)
   - [x] ✅ COMPLETED - Existing delta format works correctly
   - [x] ✅ COMPLETED - `hasChanges` flag provides no-changes detection
   - [x] ✅ COMPLETED - Delta fields: NewMessages, DeletedMessages, NewDiceRolls, EncounterStarted, EncounterEnded
   - [x] ✅ COMPLETED - No format changes needed

2. **Implement Smart Delta Filtering**
   - [x] ✅ COMPLETED - Delta service handles zero/null values
   - [x] ✅ COMPLETED - Zero values filtered when hasChanges=false
   - [x] ✅ COMPLETED - Only non-zero fields appear when hasChanges=true
   - [x] ✅ COMPLETED - "No changes to game state since last AI turn" when hasChanges=false

3. **Add No-Changes Detection**
   - [x] ✅ COMPLETED - `hasChanges` flag exists in delta format
   - [x] ✅ COMPLETED - Flag set to true/false by frontend delta service
   - [x] ✅ COMPLETED - Shared utility checks hasChanges flag
   - [x] ✅ COMPLETED - "No changes to game state since last AI turn" included in prompt when false
   - [x] ✅ COMPLETED - Full delta JSON included in prompt when true

4. **Extend Delta Service for Dice Rolls**
   - [x] ✅ COMPLETED - NewDiceRolls tracking exists
   - [x] ✅ COMPLETED - Dice rolls captured from message collector
   - [x] ✅ COMPLETED - Roll data format: formula, result, flavor, timestamp
   - [x] ✅ COMPLETED - Deltas cleared after AI turn completes

5. **Extend Delta Service for Combat Events**
   - [x] ✅ COMPLETED - EncounterStarted tracking exists
   - [x] ✅ COMPLETED - EncounterEnded tracking exists
   - [x] ✅ COMPLETED - Combat start/end detected from WebSocket collector
   - [x] ✅ COMPLETED - Combat deltas cleared after AI turn completes

6. **Update WebSocket Message Collector**
   - [x] ✅ COMPLETED - Dice roll message identification works
   - [x] ✅ COMPLETED - Roll data extraction works correctly
   - [x] ✅ COMPLETED - Combat start events tracked
   - [x] ✅ COMPLETED - Combat end events tracked
   - [x] ✅ COMPLETED - Deltas stored in message collector

7. **Update AI Orchestrator**
   - [x] ✅ COMPLETED - Uses shared utility for delta injection
   - [x] ✅ COMPLETED - HasChanges flag checked before sending
   - [x] ✅ COMPLETED - Delta formatted for AI prompt correctly
   - [x] ✅ COMPLETED - Deltas reset after AI turn completes

8. **Create Shared Delta Injection Utility** (`backend/shared/utils/ai_prompt_builder.py`)
   - [x] ✅ COMPLETED - New utility module created
   - [x] ✅ COMPLETED - `build_initial_messages_with_delta()` implemented
   - [x] ✅ COMPLETED - Extracts message_delta from universal_settings
   - [x] ✅ COMPLETED - Checks hasChanges flag
   - [x] ✅ COMPLETED - Appends full JSON dump when true
   - [x] ✅ COMPLETED - Appends "No changes to game state since last AI turn" when false
   - [x] ✅ COMPLETED - Builds user message based on AI role
   - [x] ✅ COMPLETED - Returns OpenAI message format array
   - [x] ✅ COMPLETED - api_chat.py uses shared utility
   - [x] ✅ COMPLETED - testing_harness.py uses shared utility
   - [x] ✅ COMPLETED - Single source of truth for delta injection logic

9. **Add Delta Test to Function Check** (`backend/testing/function_check.sh`)
   - [x] ✅ COMPLETED - Delta tracking tests validated
   - [x] ✅ COMPLETED - Test sessions correctly receive delta data
   - [x] ✅ COMPLETED - "No changes" scenario works correctly
   - [x] ✅ COMPLETED - Delta JSON appears when changes made
   - [x] ✅ COMPLETED - All delta fields (NewMessages, NewDiceRolls, EncounterStarted/Ended) captured

**Additional Implementation Details (Testing Harness Fix):**
- [x] ✅ COMPLETED - Made `generate_initial_prompt()` async
- [x] ✅ COMPLETED - Added polling mechanism (up to 3 seconds) to wait for delta
- [x] ✅ COMPLETED - Updated admin.py to await async call
- [x] ✅ COMPLETED - Clear stale delta before test session starts
- [x] ✅ COMPLETED - Added comprehensive debug logging
- [x] ✅ COMPLETED - Fixed race condition where testing harness got stale delta

### Acceptance Criteria

- [x] ✅ COMPLETED - Delta format works correctly (no format changes needed)
- [x] ✅ COMPLETED - Only non-zero/non-null fields appear when hasChanges=true
- [x] ✅ COMPLETED - `hasChanges` flag correctly indicates no-change scenarios
- [x] ✅ COMPLETED - `NewDiceRolls` captures all dice rolls since last AI turn
- [x] ✅ COMPLETED - `EncounterStarted` and `EncounterEnded` track combat events
- [x] ✅ COMPLETED - No console errors during delta tracking
- [x] ✅ COMPLETED - Testing harness receives exact same delta as AI service
- [x] ✅ COMPLETED - No more "zero" returns for all delta objects

---

## Feature 5: Initial Context System

**Priority:** High  
**Complexity:** High  
**Files Affected:**
- `backend/services/message_services/context_builder.py` (new service)
- `backend/services/ai_services/ai_session_manager.py` (track first turn)
- `backend/services/ai_services/ai_orchestrator.py` (context selection)
- `backend/services/system_services/service_factory.py` (register)
- `backend/shared/startup/services.py` (initialize)

### Architecture

- **First AI turn** (per client ID): Full initial context, no deltas
- **Successive AI turns** (same client ID): Deltas only, no full context
- Mutual exclusivity enforced

### Tasks

1. **Create Context Builder Service** (`context_builder.py`)
   - [ ] Create `ContextBuilder` class
   - [ ] Implement `build_initial_context(client_id)` method
   - [ ] Gather `session_info`:
     - game_system (from Foundry)
     - gm_name
     - players list
   - [ ] Gather `party_compendium`:
     - List all player-controlled characters
     - Include actor IDs and player names
   - [ ] Gather `active_scene`:
     - Scene ID
     - Scene name
     - Dimensions (width, height, grid)
     - Token list (id, name, actor_id, x, y, is_player)
   - [ ] Gather `active_encounter`:
     - Full combat data if active
     - `null` if no active combat
   - [ ] Return context object per ROADMAP.md specification

2. **Track First Turn Per Client** (`ai_session_manager.py`)
   - [ ] Add `has_first_turn_complete` flag to session data
   - [ ] Set flag to `false` on new session creation
   - [ ] Set flag to `true` after first AI turn completes
   - [ ] Add method to check first turn status

3. **Implement Context Selection Logic** (`ai_orchestrator.py`)
   - [ ] Check if session has completed first turn
   - [ ] **If first turn**:
     - Call `build_initial_context(client_id)`
     - Include full context in system prompt
     - Skip delta section entirely
     - Add section header: "World State Overview"
   - [ ] **If successive turn**:
     - Call delta service for recent changes
     - Include delta section only
     - Skip full initial context
     - Add section header: "Recent changes to the game"
   - [ ] Enforce mutual exclusivity (never both full context AND deltas)

4. **Register Context Builder Service** (`service_factory.py`)
   - [ ] Add `get_context_builder()` factory function
   - [ ] Register ContextBuilder in ServiceRegistry
   - [ ] Update service lifecycle management

5. **Initialize Context Builder** (`services.py`)
   - [ ] Import ContextBuilder
   - [ ] Register in startup sequence
   - [ ] Verify initialization succeeds

### Acceptance Criteria

- [ ] First AI turn receives full initial context
- [ ] Successive AI turns receive only deltas
- [ ] Context format matches ROADMAP.md specification
- [ ] Mutual exclusivity enforced (never both)
- [ ] Context builder successfully gathers all required data
- [ ] No console errors during context building

---

## Feature 6: Testing Infrastructure

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/testing/function_check.sh` (enhance)
- `backend/services/ai_services/testing_harness.py` (verify scope)
- `backend/testing/TESTING.md` (document limits)

### Tasks

1. **Limit Testing Harness Scope**
   - [ ] Verify testing harness ONLY simulates AI service
   - [ ] Ensure testing harness sends commands, receives responses AI would receive
   - [ ] NO feature implementation in testing harness
   - [ ] All features must be in actual server code
   - [ ] Document testing harness limitations in TESTING.md

2. **Enhance Function Check Script** (`function_check.sh`)
   - [ ] Add test for renamed tool `get_message_history`
   - [ ] Add test for renamed tool `post_message`
   - [ ] Add tests for `roll_dice`:
     - Single roll: `tool roll_dice rolls=[{"formula": "1d20+5", "flavor": "Attack"}]`
     - Multiple rolls: `tool roll_dice rolls=[{"formula": "2d6"}, {"formula": "1d8+3"}]`
     - Roll without flavor: `tool roll_dice rolls=[{"formula": "1d20"}]`
   - [ ] Add tests for `get_encounter`:
     - Out of combat: `tool get_encounter`
     - In combat: Start combat, then `tool get_encounter`
   - [ ] Display all return values for user confirmation
   - [ ] Add delta output verification tests
   - [ ] Add initial context verification tests
   - [ ] Add "no changes" scenario test

3. **Create Integration Test Plan**
   - [ ] Document full AI turn workflow test
   - [ ] Verify first turn uses full context
   - [ ] Verify successive turns use deltas
   - [ ] Verify no-changes detection works
   - [ ] End-to-end dice roll workflow test
   - [ ] Combat state monitoring verification test
   - [ ] Wait for user approval before all-up test

### Acceptance Criteria

- [ ] Function check tests all new tools
- [ ] All return values displayed for user confirmation
- [ ] Testing harness only simulates AI, no implementation
- [ ] Integration test plan documented
- [ ] All tests pass before proceeding to AI integration

---

## Feature 7: Documentation

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `CHANGELOG.md`
- `ROADMAP.md`
- `USAGE.md` (if needed)
- `backend/testing/TESTING.md` (testing limits)

### Tasks

1. **Update Tool Documentation**
   - [ ] Document all tool name changes
   - [ ] Update parameter descriptions for new tools
   - [ ] Add examples for `roll_dice`
   - [ ] Add examples for `get_encounter`
   - [ ] Document delta format changes
   - [ ] Document first-turn vs successive-turn context logic

2. **Update CHANGELOG.md**
   - [ ] Create new section `## [0.3.9] - YYYY-MM-DD`
   - [ ] Document breaking changes (tool renames)
   - [ ] Document new features:
     - Tool naming alignment
     - Dice rolling infrastructure
     - Combat status infrastructure
     - Enhanced delta tracking
     - Initial context system
   - [ ] Document delta format changes
   - [ ] Include migration notes if needed

3. **Update ROADMAP.md**
   - [ ] Mark Patch 0.3.9 items as complete
   - [ ] Update progress indicators
   - [ ] Note any deviations from original plan

4. **Document Testing Limitations** (`TESTING.md`)
   - [ ] Clarify testing harness scope
   - [ ] Document what testing harness does NOT do
   - [ ] Explain difference between testing harness and actual AI

### Acceptance Criteria

- [ ] All changes documented in CHANGELOG.md
- [ ] ROADMAP.md updated with completion status
- [ ] Tool documentation complete
- [ ] Testing limitations clearly documented

---

## Implementation Order

Recommended implementation sequence based on dependencies:

1. **Feature 1: Tool Naming Alignment** (foundation for all other features)
2. **Feature 4: Enhanced Delta Tracking** (data layer)
3. **Feature 5: Initial Context System** (data layer)
4. **Feature 2: Dice Rolling Infrastructure** (feature implementation)
5. **Feature 3: Combat Status Infrastructure** (feature implementation)
6. **Feature 6: Testing Infrastructure** (validation)
7. **Feature 7: Documentation** (finalization)

---

## Testing Checklist

Before merging to main:

### Function Check Tests
- [ ] `get_message_history` returns correct data
- [ ] `post_message` sends messages correctly
- [ ] `roll_dice` executes rolls and returns results
- [ ] `get_encounter` returns combat state or no-encounter response
- [ ] Delta output displays correctly
- [ ] Initial context displays correctly on first turn

### Integration Tests
- [ ] Full AI turn with actual AI service
- [ ] First turn uses full initial context
- [ ] Successive turns use deltas only
- [ ] No-changes detection works correctly
- [ ] Dice roll executes in Foundry and result returns to AI
- [ ] Combat state updates reflected in AI responses
- [ ] Tool renames don't break existing functionality

### Manual Testing
- [ ] Module loads without errors
- [ ] Settings menu opens correctly
- [ ] Backend connection works
- [ ] AI chat works with new tools
- [ ] Dice rolls execute in Foundry chat
- [ ] Combat state updates when combat starts/ends
- [ ] Deltas display correctly in logs
- [ ] No console errors in browser

---

## Branch Management

### Create Feature Branch
```bash
git checkout main
git pull origin main
git checkout -b feature/0.3.9-the-foundation
```

### Commit Strategy
- Separate commits per feature for easier review
- Use descriptive commit messages with prefixes:
  - `feat:` for new features
  - `refactor:` for code refactoring
  - `fix:` for bug fixes
  - `docs:` for documentation

### Merge to Main
```bash
git checkout main
git merge feature/0.3.9-the-foundation
git push origin main
```

### Tag Release
```bash
git tag v0.3.9
git push origin v0.3.9
```

---

## Release Notes

### Breaking Changes
- Tool names renamed: `get_messages` → `get_message_history`, `post_messages` → `post_message`
- Delta format updated to match ROADMAP.md specification

### New Features
- AI can execute dice rolls in Foundry
- AI can query current combat encounter state
- Smart delta filtering (zero/null values omitted)
- No-changes detection for efficient AI context
- First-turn vs successive-turn context logic

### Migration Notes
- No manual migration required for existing installations
- Tool names updated automatically
- Context switching handled automatically

---

**End of Implementation Plan**
