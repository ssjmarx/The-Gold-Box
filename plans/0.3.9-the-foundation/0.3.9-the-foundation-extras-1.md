# Combat Status Infrastructure Polish Plan

**Version:** 0.3.9-extras-1  
**Related Patch:** 0.3.9-the-foundation  
**Feature:** Combat Status Infrastructure  
**Status:** Ready for Implementation  
**Date:** 2025-12-28

---

## Overview

This plan addresses logspam, timeout warnings, and redundant data transmission identified during all-up testing of Feature 3: Combat Status Infrastructure.

## Issues Identified

### 1. Combat State Auto-Refresh Causing Logspam and Timeouts

**Problem:**
- CombatMonitor automatically transmits combat state on every event (combat start, turn change, combatant added/removed)
- This floods logs with 15+ combat_state messages per AI turn
- When get_encounter requests a refresh via `combat_state_refresh`, the response timing causes 2-second timeout warnings
- Timeout falls back to cached state, but logs show WARNING level on every call

**Root Cause:**
Frontend maintains constant state through event listeners (needed), but backend only needs updated state when get_encounter is called (not on every event).

**Solution:**
- Frontend: Remove automatic `transmitCombatState()` from event handlers; only transmit on explicit `combat_state_refresh` request
- Backend: Increase timeout from 2s to 5s (matching health check fix), change timeout log from WARNING to DEBUG

---

### 2. Redundant Logging

**Problem:** Multiple redundant log entries clutter output and make debugging difficult.

**Issues:**
1. **Duplicate combat state logging** (2 consecutive lines):
   ```
   INFO - Updated combat state for client {id}: in_combat=True
   INFO - Combat state stored for client {id}: in_combat=True
   ```

2. **Tool availability logging** (appears before every AI call):
   ```
   INFO - Tools available to AI: 4 tools
     - get_message_history
     - post_message
     - roll_dice
     - get_encounter
   ```

3. **Verbose roll result processing** (6 log lines per roll):
   - WebSocket routing
   - Handler calls
   - Data extraction
   - Future handling
   - Result setting
   - Cleanup

**Solution:**
- Keep only: "Updated combat state for client {id}: in_combat=True"
- Change tool availability to DEBUG level or log once at startup
- Consolidate roll processing to 2-3 lines or move internal steps to DEBUG
- **Retain:** All "ADD MESSAGE TO CONVERSATION" blocks with actual message content

---

### 3. Duplicate Combat Data in Message History

**Problem:** `combat_context` messages appear in get_message_history results, but combat state should only come from get_encounter.

**Impact:**
- AI receives combat data twice (via message history and via get_encounter)
- Violates separation of concerns between tools
- Inconsistent data source for AI

**Solution:**
- Filter out `combat_context` message type from get_message_history
- Combat state only accessible via get_encounter tool

---

## Implementation Plan

### Step 1: CombatMonitor Auto-Refresh Fix

**File:** `scripts/api/combat-monitor.js`

**Actions:**
1. Review all event handlers (createCombat, updateCombat, deleteCombat, createCombatant, deleteCombatant, updateCombatant)
2. Remove `transmitCombatState()` calls from event handlers
3. Keep internal state updates (maintain CombatMonitor's knowledge of current state)
4. Ensure `transmitCombatState()` only called on `combat_state_refresh` WebSocket message
5. Verify event listeners still fire (needed for internal state tracking)

**Expected Change:**
- No automatic combat_state messages transmitted
- CombatMonitor still tracks state changes internally
- State transmitted only when backend requests it

---

### Step 2: Timeout and Log Level Fix

**File:** `backend/services/ai_tools/ai_tool_executor.py`

**Actions:**
1. Locate `execute_get_encounter()` method
2. Find timeout parameter (currently 2 seconds)
3. Change to 5 seconds to match health check timeout
4. Find timeout log statement (currently WARNING level)
5. Change to DEBUG level

**Code Change:**
```python
# Before:
await asyncio.wait_for(future, timeout=2.0)
logger.warning(f"get_encounter: Timeout waiting for combat state, request_id: {request_id}")

# After:
await asyncio.wait_for(future, timeout=5.0)
logger.debug(f"get_encounter: Timeout waiting for combat state, request_id: {request_id}")
```

---

### Step 3: Consolidate Combat State Logging

**File:** `backend/services/message_services/websocket_message_collector.py`

**Actions:**
1. Find combat state handling in WebSocket message processing
2. Identify the two consecutive log lines:
   - "Updated combat state for client {client_id}: in_combat=True"
   - "Combat state stored for client {client_id}: in_combat=True"
3. Remove the "Combat state stored" line
4. Keep only "Updated combat state" line

---

### Step 4: Reduce Tool Availability Logging

**File:** `backend/services/ai_services/ai_orchestrator.py`

**Actions:**
1. Find tool availability logging (appears before each AI call)
2. Two options:
   - **Option A:** Move to DEBUG level
   - **Option B:** Log once at startup only
3. Implement chosen option

**Recommended:** Option A (DEBUG level) - less invasive, still available when needed for debugging

---

### Step 5: Consolidate Roll Result Logging

**File:** `backend/services/ai_tools/ai_tool_executor.py`

**Actions:**
1. Find `_handle_roll_result()` method or roll result processing logic
2. Identify 6 consecutive log lines for single roll processing
3. Consolidate to 2-3 lines:
   - Line 1: "Received roll_result for request {id} with {count} results"
   - Line 2: "Result set successfully for request {id}"
4. Move internal steps (routing, data extraction, future handling) to DEBUG level

---

### Step 6: Filter Combat Context from Message History

**File:** `backend/services/message_services/websocket_message_collector.py`

**Actions:**
1. Find message collection logic (likely in `collect_messages()` or similar)
2. Add filter to skip messages with `t` (type) == "combat_context"
3. Test: verify get_message_history no longer includes combat_context messages
4. Verify other message types still collected correctly

**Code Change:**
```python
# Add filter in message collection loop
if message.get('t') == 'combat_context':
    continue  # Skip combat context messages
```

---

### Step 7: Testing

**Actions:**
1. Run function check for get_encounter
2. Start combat in Foundry
3. Verify no timeout warnings in logs
4. Verify logs are cleaner (no duplicate combat state entries)
5. Verify get_message_history has no combat_context
6. Verify get_encounter returns correct combat state
7. Verify tool availability not spamming logs
8. Verify roll result logs consolidated

**Expected Results:**
- 0 automatic combat_state logs (only on explicit request)
- No WARNING messages for timeouts (DEBUG level or resolved)
- Clean, concise logging
- combat_context only via get_encounter
- Combat state still fresh and accurate when needed

---

## Files Modified

1. `scripts/api/combat-monitor.js` - Remove auto-transmit from event handlers
2. `backend/services/ai_tools/ai_tool_executor.py` - Timeout, log level, roll result logging
3. `backend/services/message_services/websocket_message_collector.py` - Combat state logging, combat_context filter
4. `backend/services/ai_services/ai_orchestrator.py` - Tool availability logging

---

## Implementation Order

1. CombatMonitor auto-refresh fix (foundational)
2. Timeout and log level fix (foundational)
3. Combat state logging consolidation (cleanup)
4. Tool availability logging reduction (cleanup)
5. Roll result logging consolidation (cleanup)
6. Combat context filtering (data cleanup)
7. Testing (validation)

---

## Success Criteria

- [x] No automatic combat_state transmissions in logs
- [x] No timeout WARNING messages
- [x] Single log line for combat state updates
- [x] Tool availability not spamming logs
- [x] Roll result processing logs consolidated
- [x] get_message_history excludes combat_context
- [x] get_encounter returns full combat state
- [x] All function check tests pass
- [x] No console errors

---

## Notes

- CombatMonitor still needs event listeners for internal state tracking
- Only automatic TRANSMISSION is removed, not event listening
- get_encounter timeout increase matches health check timeout (5 seconds)
- All message content logs retained (user requirement)
- Duplicate dice roll issue deferred (low priority edge case)

---

**End of Plan**
