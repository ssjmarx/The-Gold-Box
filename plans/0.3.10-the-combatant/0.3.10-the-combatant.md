# Implementation Plan: Patch 0.3.10 - The Combatant

**Version:** 0.3.10  
**Branch:** `feature/0.3.10-the-combatant`  
**Status:** ðŸš§ IN PLANNING  
**Goal:** Give AI the tools to actively manage and participate in combat encounters, moving from passive observer to active combatant

---

## Overview

Patch 0.3.10 implements combat management tools as outlined in ROADMAP.md. This patch focuses on giving the AI agency over combat flow and actor health, enabling it to start/stop encounters, advance turns, query detailed actor information, and apply damage/healing. The implementation builds on the foundation established in 0.3.9.

### Key Deliverables

1. **Combat Encounter Management** - Create and delete combat encounters
2. **Turn Management** - Advance combat turns automatically
3. **Actor Details Query** - Retrieve detailed stat blocks for any actor
4. **Health Management** - Apply damage and healing to actors
5. **Enhanced Delta Tracking** - Track turn advances and combatant state changes
6. **Testing Infrastructure** - Comprehensive tests for all new combat features

---

## Feature 1: Combat Encounter Management âœ… COMPLETE

**Priority:** High  
**Complexity:** Medium  
**Status:** âœ… COMPLETED (2025-01-01)
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tools)
- `backend/services/ai_tools/ai_tool_executor.py` (new executors)
- `scripts/services/dice-roll-executor.js` (enhance for initiative)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ create_encounter(actor_ids) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                               â†“
Combat created, initiative rolled â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI

AI â†’ delete_encounter() â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                          â†“
Combat ended â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

### Tasks

1. **Implement `create_encounter` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "create_encounter",
             "description": "Start a new combat encounter with specified actors. Use roll_initiative parameter to control automatic initiative rolling (false for systems that handle initiative manually, e.g., card-based or dice-pool games). Creates combat and advances to turn 1 if successful.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "actor_ids": {
                         "type": "array",
                         "items": {"type": "string"},
                         "description": "Array of actor IDs to add to the encounter"
                     },
                     "roll_initiative": {
                         "type": "boolean",
                         "description": "Whether to roll initiative for all combatants (default: true)",
                         "default": True
                     }
                 },
                 "required": ["actor_ids"]
             }
         }
     }
     ```
   - Validate parameter schemas
   - Add example usage in comments

2. **Implement `create_encounter` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_create_encounter()` method
   - Validate input parameters (actor_ids array non-empty)
   - Send encounter creation request to frontend via WebSocket
   - Include roll_initiative flag in request
   - Await combat state response from frontend (5 second timeout)
   - Return confirmation with encounter details
   - Handle timeout and error cases (no actors found, combat already active, etc.)

3. **Implement `delete_encounter` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with no parameters
   - Validate no parameters required
   - Add description: "End the current combat encounter"

4. **Implement `delete_encounter` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_delete_encounter()` method
   - Check if combat is active (get from message collector)
   - If no active combat, return: `{"success": false, "message": "No active encounter to end"}`
   - Send encounter deletion request to frontend via WebSocket
   - Await combat state response (5 second timeout)
   - Return confirmation with deletion status
   - Handle timeout and error cases

5. **Add Encounter Management Message Types** (`message_protocol.py`)
   - Add `TYPE_CREATE_ENCOUNTER = "create_encounter"` constant
   - Add `TYPE_DELETE_ENCOUNTER = "delete_encounter"` constant
   - Add `TYPE_ACTOR_DETAILS = "actor_details"` constant (for responses)
   - Document message formats in protocol specification
   - Response pattern: All encounter tools respond with `combat_state` message type (consistent with existing `get_encounter`)

6. **Create Frontend Encounter Manager** (`scripts/api/combat-monitor.js` - enhance)
   - Add handler for `create_encounter` WebSocket message
   - Validate actor_ids array
   - Create combat using Foundry's Combat API: `game.combats.create([...])`
   - If roll_initiative=true, call `combat.rollAll()` for all combatants
   - If roll_initiative=true, advance to first turn: `combat.nextRound()` if needed
   - Transmit updated combat state via WebSocket
   - Add handler for `delete_encounter` WebSocket message
   - End combat using Foundry's Combat API: `game.combat.endCombat()`
   - Transmit combat ended state via WebSocket
   - Handle errors (invalid actor IDs, combat already active, etc.)

7. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `create_encounter` messages
   - Route to CombatMonitor
   - Send responses back to backend
   - Add handler for incoming `delete_encounter` messages
   - Route to CombatMonitor
   - Send responses back to backend
   - Add error handling for encounter operations

8. **Add Function Check Tests** (`function_check.sh`)
   - Add test for create_encounter with initiative: `tool create_encounter actor_ids=["<actor_id1>","<actor_id2>"] roll_initiative=true`
   - Add test for create_encounter without initiative: `tool create_encounter actor_ids=["<actor_id>"] roll_initiative=false`
   - Add test for delete_encounter: `tool delete_encounter`
   - Add test for error when combat already active: Try create_encounter twice
   - Add test for error when no combat active: Try delete_encounter out of combat
   - Verify combat state updates correctly
   - Verify initiative rolls appear in chat if roll_initiative=true

### Acceptance Criteria

- [x] AI can create combat encounters with specified actors
- [x] AI can choose whether to roll initiative automatically
- [x] Frontend creates combat using Foundry's native API
- [x] Initiative rolls executed in Foundry when requested
- [x] Combat advances to turn 1 automatically
- [x] AI can delete/end active encounters
- [x] Appropriate error messages for invalid states
- [x] All tests in function_check.sh pass
- [x] No console errors during encounter management

### Implementation Notes

**Bug Fixes Implemented:**
1. **Error Handling for Duplicate Combat Creation** (2025-01-01)
   - Fixed: create_encounter would timeout (30s) when combat already active
   - Solution: Frontend now sends immediate error message when combat exists
   - Backend: Added `_handle_error_message` handler in services.py to process error messages
   - Result: Error returned immediately: "Combat encounter already active (code: COMBAT_ALREADY_ACTIVE)"
   - Files modified:
     - `scripts/api/combat-monitor.js` - Added validation and error response
     - `backend/shared/startup/services.py` - Added error message handler
     - `backend/services/ai_tools/ai_tool_executor.py` - Already had proper exception handling

**Test Results:**
- All 15 test commands passed successfully
- create_encounter with initiative: âœ…
- create_encounter (already active): âœ… Returns immediate error (no timeout)
- delete_encounter: âœ…
- delete_encounter (no combat): âœ… Returns appropriate error
- All other features working correctly

---

## Feature 2: Turn Management

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `scripts/api/combat-monitor.js` (enhance)
- `backend/shared/core/message_protocol.py` (new message type)
- `scripts/api/websocket-communicator.js` (message handling)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ advance_combat_turn() â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                          â†“
Turn advanced â†’ CombatMonitor â†’ Combat state â†’ Backend â†’ AI
```

### Tasks

1. **Implement `advance_combat_turn` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with no parameters
   - Validate no parameters required
   - Add description: "Advance the combat tracker to the next turn. Use this to move through turn order for multiple combatants efficiently. Multiple calls can be made in a single response (e.g., advance turn, move and attack, advance turn, move and attack, for NPCs with adjacent turns)."

2. **Implement `advance_combat_turn` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_advance_combat_turn()` method
   - Check if combat is active (get from message collector)
   - If no active combat, return: `{"success": false, "message": "No active encounter"}`
   - Send turn advance request to frontend via WebSocket
   - Await combat state response (5 second timeout)
   - Return confirmation with new turn details
   - Handle timeout and error cases

3. **Add Turn Management Message Type** (`message_protocol.py`)
   - Add `TYPE_ADVANCE_TURN = "advance_turn"` constant
   - Document message formats in protocol specification
   - Response pattern: Frontend responds with `combat_state` message type (consistent with existing `get_encounter`)

4. **Enhance Frontend Combat Monitor** (`combat-monitor.js`)
   - Add handler for `advance_turn` WebSocket message
   - Check if combat is active
   - Advance turn using Foundry's Combat API: `game.combat.nextTurn()`
   - Transmit updated combat state via WebSocket
   - Handle errors (no combat active, end of round, etc.)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `advance_turn` messages
   - Route to CombatMonitor
   - Send responses back to backend
   - Add error handling for turn advancement

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for advance_combat_turn in active combat
   - Add test for error when no combat active: Try advance out of combat
   - Verify turn advances correctly
   - Verify combat state updates with new turn
   - Verify end-of-round handling if needed

### Acceptance Criteria

- [ ] AI can advance combat turns
- [ ] Frontend uses Foundry's native combat API
- [ ] Turn order updates correctly
- [ ] Combat state reflects new turn
- [ ] Appropriate error messages when no combat active
- [ ] All tests in function_check.sh pass
- [ ] No console errors during turn management

---

## Feature 3: Token Actor Details Query

**Priority:** High  
**Complexity:** Medium  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ get_actor_details(token_id, search_phrase) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                              â†“
Token actor data â†’ Backend â†’ WebSocket â†’ Frontend â†’ Result â†’ AI
```

**Token-Specific Approach:**
- Queries token-specific actor instances (e.g., `Scene.XXX.Token.YYY.Actor.ZZZ`)
- Each token in combat has its own actor sheet with unique HP
- Returns complete actor data structure with field names for attribute modification

### Tasks

1. **Implement `get_actor_details` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "get_actor_details",
             "description": "Retrieve a detailed stat block for a token-specific actor instance. Returns complete actor data structure including all field names (e.g., 'attributes.hp.value', 'attributes.ac.value') which can be used with modify_token_attribute. Optional search_phrase performs grep-like search (case-insensitive, exact substring match) returning matching field paths, values, and context (parent/child/sibling fields). Similar to grep: searches all fields, returns matches with surrounding context. Leave empty to return full actor sheet.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "token_id": {
                         "type": "string",
                         "description": "The token-specific actor UUID (e.g., 'Scene.XXX.Token.YYY.Actor.ZZZ')"
                     },
                     "search_phrase": {
                         "type": "string",
                         "description": "Optional search phrase (case-insensitive, exact substring match). Returns matching field paths, values, and context. Similar to grep: searches all fields, returns matches with surrounding context (parent/child/sibling fields). Leave empty to return full actor sheet."
                     }
                 },
                 "required": ["token_id"]
             }
         }
     }
     ```
   - Validate parameter schemas
   - Add example usage in comments:
     ```python
     # Example: Get full actor sheet
     tool = {"name": "get_actor_details", "arguments": {"token_id": "Scene.XXX.Token.YYY.Actor.ZZZ"}}
     
     # Example: Search for HP-related fields (grep-like)
     tool = {"name": "get_actor_details", "arguments": {"token_id": "...", "search_phrase": "hp"}}
     # Returns matches for "hp.value", "hp.max", "hp.temp" with context
     
     # Example: Search for weapon
     tool = {"name": "get_actor_details", "arguments": {"token_id": "...", "search_phrase": "sword"}}
     # Returns matches for item names, damage types, properties with context
     ```

2. **Implement `get_actor_details` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_get_actor_details()` method
   - Validate input parameters
   - Send token actor details request to frontend via WebSocket
   - Include token_id and search_phrase in request
   - Await actor data response (5 second timeout)
   - Format and return actor details to AI
   - Handle timeout and error cases (token not found, etc.)

3. **Add Token Actor Details Message Types** (`message_protocol.py`)
   - Add `TYPE_GET_ACTOR_DETAILS = "get_actor_details"` constant
   - Add `TYPE_TOKEN_ACTOR_DETAILS = "token_actor_details"` constant (for responses)
   - Document message formats in protocol specification
   - Response pattern: Frontend responds with `token_actor_details` message type containing complete actor data structure

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `getTokenActorDetails(token_id, search_phrase)` method
   - Get token from canvas: `canvas.tokens.get(token_id)`
   - Get token-specific actor: `token.actor` (already token-specific instance)
   
   **Search Functionality (Grep-Like):**
   - **Without search_phrase**: Return complete actor data structure
   - **With search_phrase**: Perform grep-like search
     1. Flatten actor data to path-value pairs
     2. Filter for matches (case-insensitive, exact substring)
     3. Add context for each match (parent + sibling fields)
     4. Return structured matches array
   
   **Search Algorithm:**
   ```javascript
   function searchActorData(actor, phrase) {
       // 1. Flatten actor.system to path-value pairs
       const flattened = flattenObject(actor.system);
       // Returns: [
       //   {path: "attributes.hp.value", value: 15},
       //   {path: "attributes.hp.max", value: 27},
       //   ...150 total fields
       // ]
       
       // 2. Filter for matches (case-insensitive, exact substring)
       const matches = flattened.filter(f => 
           f.path.toLowerCase().includes(phrase.toLowerCase()) ||
           String(f.value).toLowerCase().includes(phrase.toLowerCase())
       );
       
       // 3. Add context (parent + sibling fields)
       matches.forEach(match => {
           const parentPath = match.path.split('.').slice(0, -1).join('.');
           match.context = {
               parent: parentPath,
               siblings: getSiblingFields(flattened, parentPath)
           };
       });
       
       return {
           name: actor.name,
           matches: matches,
           summary: {
               total_matches: matches.length,
               fields_searched: flattened.length
           }
       };
   }
   ```
   
   **Return Formats:**
   
   *Without search_phrase:*
   ```javascript
   {
       name: "Goblin",
       system: { /* complete actor data */ }
   }
   ```
   
   *With search_phrase = "hp":*
   ```javascript
   {
       name: "Goblin",
       matches: [
           {
               path: "system.attributes.hp.value",
               value: 15,
               context: {
                   parent: "system.attributes.hp",
                   siblings: {
                       max: 27,
                       temp: 0,
                       formula: "6 + 2d6"
                   }
               }
           },
           {
               path: "system.attributes.hp.max",
               value: 27,
               context: {
                   parent: "system.attributes.hp",
                   siblings: {value: 15, temp: 0}
               }
           }
       ],
       summary: {
           total_matches: 2,
           fields_searched: 150
       }
   }
   ```
   
   *With search_phrase = "sword":*
   ```javascript
   {
       name: "Fighter",
       matches: [
           {
               path: "system.items.0.name",
               value: "Longsword",
               context: {
                   parent: "system.items.0",
                   siblings: {
                       type: "weapon",
                       damage: {parts: [{formula: "1d8 + 3", type: "slashing"}]}
                   }
               }
           }
       ],
       summary: {total_matches: 1, fields_searched: 150}
   }
   ```
   
   **Edge Cases:**
   - *No matches*: Return `{name, matches: [], summary: {total_matches: 0, fields_searched: N}}`
   - *Multiple matches on same object*: Return all matches with overlapping context (expected grep behavior)
   - *Case-insensitive*: "HP" matches "hp", "HP", "Hp"
   - *Substring match*: "fire" matches "fireball", "fire breath", "fire resistance"
   - *Numeric search*: "12" matches numeric values (e.g., STR score of 12, AC of 12)
   
   - Handle errors (token not found)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `get_actor_details` messages
   - Route to WorldStateCollector
   - Send `token_actor_details` responses back to backend
   - Add error handling for token queries

6. **Add Function Check Tests** (`function_check.sh`)
   - Add test for get_actor_details with token (no search): `tool get_actor_details token_id="<token_uuid>"`
   - Add test for get_actor_details with search phrase "hp": `tool get_actor_details token_id="<token_uuid>" search_phrase="hp"`
   - Add test for get_actor_details with search phrase "sword": `tool get_actor_details token_id="<token_uuid>" search_phrase="sword"`
   - Add test for get_actor_details with numeric search: `tool get_actor_details token_id="<token_uuid>" search_phrase="12"`
   - Add test for no matches: `tool get_actor_details token_id="<token_uuid>" search_phrase="nonexistent"`
   
   **Verify:**
   - Without search: Returns complete actor data structure with field names
   - With "hp" search: Returns matches for "hp.value", "hp.max", "hp.temp" with context
   - With "sword" search: Returns item names, damage types, properties with context
   - Search is case-insensitive ("HP" matches "hp")
   - Search is substring ("fire" matches "fireball")
   - No matches: Returns empty matches array with summary
   - Error handling for invalid token_id

### Acceptance Criteria

- [ ] AI can query token-specific actor details
- [ ] Actor data includes complete stat block with field names
- [ ] Field names match Foundry's internal structure (e.g., "attributes.hp.value")
- [ ] Search phrase returns relevant context
- [ ] Appropriate error messages for invalid token IDs
- [ ] All tests in function_check.sh pass
- [ ] No console errors during actor queries

---

## Feature 4: Token Attribute Management

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (new tool)
- `backend/services/ai_tools/ai_tool_executor.py` (new executor)
- `backend/shared/core/message_protocol.py` (new message types)
- `scripts/api/websocket-communicator.js` (message handling)
- `scripts/services/world-state-collector.js` (new method)
- `scripts/api/combat-monitor.js` (combat state updates)
- `backend/testing/function_check.sh` (test cases)

### Architecture

```
AI â†’ modify_token_attribute(token_id, attribute_path, value, is_delta, is_bar) â†’ Backend â†’ WebSocket â†’ Frontend â†’ Foundry API
                                                                                                        â†“
Attribute modified â†’ Combat state â†’ Backend â†’ AI
```

**System-Agnostic Approach:**
- Uses Foundry's `modifyTokenAttribute()` API
- Works with any game system's attribute structure
- AI sees field names from actor details, can modify any token attribute

### Tasks

1. **Implement `modify_token_attribute` Tool Definition** (`ai_tool_definitions.py`)
   - Add tool definition with parameters:
     ```python
     {
         "type": "function",
         "function": {
             "name": "modify_token_attribute",
             "description": "Modify a token's attribute using Foundry's native API. Use field names from get_actor_details (e.g., 'attributes.hp.value', 'attributes.ac.value'). Multiple tokens can be updated in a single response (e.g., apply multi-target spell damage to multiple NPCs together). Set is_delta=true for relative changes (damage/healing), is_delta=false for absolute values. Set is_bar=true to update token bar display.",
             "parameters": {
                 "type": "object",
                 "properties": {
                     "token_id": {
                         "type": "string",
                         "description": "The token ID to update"
                     },
                     "attribute_path": {
                         "type": "string",
                         "description": "Attribute path to modify (e.g., 'attributes.hp.value')"
                     },
                     "value": {
                         "type": "number",
                         "description": "Value to set (if is_delta=false) or add/subtract (if is_delta=true)"
                     },
                     "is_delta": {
                         "type": "boolean",
                         "description": "Whether value is a relative change (true) or absolute (false). Default: true for damage/healing"
                     },
                     "is_bar": {
                         "type": "boolean",
                         "description": "Whether to update token bar display. Default: true"
                     }
                 },
                 "required": ["token_id", "attribute_path", "value"]
             }
         }
     }
     ```
   - Validate parameter schemas
   - Add example usage in comments

2. **Implement `modify_token_attribute` Tool Executor** (`ai_tool_executor.py`)
   - Add `execute_modify_token_attribute()` method
   - Validate input parameters
   - Send token attribute modification request to frontend via WebSocket
   - Include token_id, attribute_path, value, is_delta, and is_bar in request
   - Await combat state response (5 second timeout)
   - Return confirmation with updated attribute values
   - Handle timeout and error cases (token not found, invalid attribute path, etc.)

3. **Add Token Attribute Management Message Types** (`message_protocol.py`)
   - Add `TYPE_MODIFY_TOKEN_ATTRIBUTE = "modify_token_attribute"` constant
   - Document message formats in protocol specification
   - Response pattern: Frontend responds with `combat_state` message type after modification

4. **Enhance Frontend World State Collector** (`world-state-collector.js`)
   - Add `modifyTokenAttribute(token_id, attribute_path, value, is_delta, is_bar)` method
   - Get token from canvas: `canvas.tokens.get(token_id)`
   - Use Foundry's native `modifyTokenAttribute()` API:
     ```javascript
     await token.document.modifyTokenAttribute(attribute_path, value, {
         isDelta: is_delta,
         isBar: is_bar
     });
     ```
   - If token in combat, call `combat-monitor.updateCombatState(game.combat)` to update combat state
   - Transmit updated combat state if token in combat
   - Return updated attribute value
   - Handle errors (token not found, invalid attribute path, etc.)

5. **Update WebSocket Communicator** (`websocket-communicator.js`)
   - Add handler for incoming `modify_token_attribute` messages
   - Route to WorldStateCollector
   - Send responses back to backend
   - Add error handling for token attribute modifications

6. **Update Combat State Structure** (`combat-monitor.js`)
   - Add `token_id` field to each combatant (token UUID)
   - Add `actor_uuid` field to each combatant (token-specific actor UUID)
   - Example structure:
     ```javascript
     {
         name: "Goblin #2",
         token_id: "Scene.XXX.Token.YYY",
         actor_uuid: "Scene.XXX.Token.YYY.Actor.ZZZ",
         initiative: 12,
         is_player: false,
         is_current_turn: true
     }
     ```
   - Update all combat state generation to include these fields

7. **Add Function Check Tests** (`function_check.sh`)
   - Add test for damage: `tool modify_token_attribute token_id="<token_id>" attribute_path="attributes.hp.value" value=-15 is_delta=true is_bar=true`
   - Add test for healing: `tool modify_token_attribute token_id="<token_id>" attribute_path="attributes.hp.value" value=10 is_delta=true is_bar=true`
   - Add test for absolute value: `tool modify_token_attribute token_id="<token_id>" attribute_path="attributes.hp.value" value=25 is_delta=false is_bar=true`
   - Verify attribute updates correctly
   - Verify token bar display updates
   - Verify combat state updates with new values
   - Verify error handling for invalid token_id
   - Verify error handling for invalid attribute_path

### Acceptance Criteria

- [ ] AI can modify any token attribute using Foundry's native API
- [ ] AI can apply damage and healing to tokens
- [ ] Attribute updates work system-agnostically (D&D, Pathfinder, etc.)
- [ ] Token bar display updates correctly when is_bar=true
- [ ] Relative changes work (is_delta=true) for damage/healing
- [ ] Absolute values work (is_delta=false) for setting values
- [ ] Combat state updates with modified token attributes
- [ ] Combat state includes token_id and actor_uuid for all combatants
- [ ] Appropriate error messages for invalid requests
- [ ] All tests in function_check.sh pass
- [ ] No console errors during token attribute management

---

## Feature 5: Enhanced Delta Tracking

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/services/message_services/message_delta_service.py` (new deltas)
- `backend/services/message_services/websocket_message_collector.py` (track new deltas)
- `scripts/api/combat-monitor.js` (transmit new deltas)
- `backend/testing/function_check.sh` (delta tests)

### Tasks

1. **Add TurnAdvanced Delta** (`message_delta_service.py`)
   - Add `TurnAdvanced` field to delta format
   - Value: `true` when turn advances
   - Clear after AI turn completes

2. **Add CombatantChanged Delta** (`message_delta_service.py`)
   - Add `CombatantChanged` field to delta format
   - Structure:
     ```json
     {
       "token_id": "string",
       "attribute_path": "string",
       "old_value": "any",
       "new_value": "any",
       "change_type": "damage" | "healing" | "other"
     }
     ```
   - Track ANY token attribute changes, not just HP
   - Clear after AI turn completes

3. **Track Turn Advances in Frontend** (`combat-monitor.js`)
   - On `updateCombat` hook (turn changes):
     - Set `TurnAdvanced: true` in delta
     - Include turn number in delta
     - Send delta to backend via WebSocket

4. **Track Combatant Changes in Frontend** (`combat-monitor.js`)
   - On `updateCombatant` hook:
     - Detect ANY attribute changes (not just HP)
     - Track token_id, attribute_path, old_value, new_value
     - Determine change_type (damage/healing/other)
     - Set `CombatantChanged` in delta with relevant data
     - Send delta to backend via WebSocket

5. **Add Delta Tests** (`function_check.sh`)
   - Test TurnAdvanced delta after advancing turn
   - Test CombatantChanged delta after attribute modification
   - Test CombatantChanged delta tracks attribute_path and values
   - Verify deltas cleared after AI turn

### Acceptance Criteria

- [ ] TurnAdvanced delta tracks turn advances
- [ ] CombatantChanged delta tracks any token attribute changes
- [ ] CombatantChanged delta includes token_id, attribute_path, old_value, new_value
- [ ] Deltas transmitted from frontend to backend
- [ ] Deltas included in AI context when changes occur
- [ ] Deltas cleared after AI turn completes
- [ ] All delta tests in function_check.sh pass

---

## Feature 6: Testing Infrastructure

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/testing/function_check.sh` (comprehensive test suite)

### Tasks

1. **Add Combat Management Tests**
   - Test create_encounter with initiative
   - Test create_encounter without initiative
   - Test delete_encounter
   - Test error when combat already active
   - Test error when no combat active

2. **Add Turn Management Tests**
   - Test advance_combat_turn
   - Test error when no combat active
   - Verify turn order updates

3. **Add Token Actor Details Tests**
   - Test get_actor_details with token_id (no search) - returns full sheet
   - Test get_actor_details with search phrase "hp" - grep-like output
   - Test get_actor_details with search phrase "sword" - grep-like output
   - Test get_actor_details with numeric search "12" - matches values
   - Test case-insensitivity ("HP" matches "hp")
   - Test substring matching ("fire" matches "fireball")
   - Test no matches scenario
   - Verify actor data includes field names
   - Verify context includes parent and sibling fields
   - Verify summary includes total_matches and fields_searched
   - Test error handling for invalid token_id

4. **Add Token Attribute Management Tests**
   - Test damage application with is_delta=true
   - Test healing application with is_delta=true
   - Test absolute value setting with is_delta=false
   - Test token bar display updates (is_bar=true)
   - Verify combat state updates with modified attributes
   - Test error handling for invalid token_id
   - Test error handling for invalid attribute_path

5. **Add Delta Tracking Tests**
   - Test TurnAdvanced delta
   - Test CombatantChanged delta (HP)
   - Test CombatantChanged delta (status effects)
   - Verify delta clearing

6. **Integration Tests**
   - Full combat workflow: create â†’ advance â†’ damage â†’ advance â†’ delete
   - Actor query workflow: create combat â†’ query actor â†’ apply damage â†’ query again
   - Multi-combatant encounter with multiple turns

### Acceptance Criteria

- [ ] All new tools tested individually
- [ ] Integration tests validate complete workflows
- [ ] All tests pass
- [ ] Test documentation complete

---

## Feature 8: Prompt Engineering Enhancements

**Priority:** High  
**Complexity:** Low  
**Files Affected:**
- `backend/services/ai_tools/ai_tool_definitions.py` (update existing tool descriptions)
- `backend/shared/core/unified_message_processor.py` (update role prompts)

### Tasks

1. **Update `post_message` Tool Description** (`ai_tool_definitions.py`)
   - Current: "Send one or more chat messages or chat cards to Foundry as your response. Messages can be chat text, or structured chat cards with Foundry-specific formatting. This function accepts markdown styling."
   - Updated: "Send one or more chat messages or chat cards to Foundry as your response. Multiple messages can be batched in a single call (e.g., combine narrative text, dice rolls, and results together). Accepts markdown styling. Use messages array to batch multiple outputs efficiently."

2. **Update `roll_dice` Tool Description** (`ai_tool_definitions.py`)
   - Current: "Roll one or more Foundry-formatted dice formulas. Each roll can include optional flavor text. The rolls are executed in Foundry and the results are returned."
   - Updated: "Roll one or more Foundry-formatted dice formulas. Multiple rolls can be batched in a single call (e.g., roll attack and damage together, or roll multiple saving throws simultaneously). Each roll can include optional flavor text. The rolls are executed in Foundry and the results are returned."

3. **Update `get_message_history` Tool Description** (`ai_tool_definitions.py`)
   - Current: "Retrieve recent chat messages from Foundry chat for context. Use once at the start of a turn to get new messages."
   - Updated: "Retrieve recent chat messages from Foundry chat for context. Call at the start of your turn to get new messages. Efficient: only call once per turn, not before each tool use."

### Role Prompt Updates

4. **Update GM Role Prompt** (`unified_message_processor.py`)
   - Current: "You are assigned as a full gamemaster. Your role is to describe scene, describe NPC actions, and create dice rolls whenever NPCs do anything that requires one. Keep generating descriptions, actions, and dice rolls until every NPC in the scene has gone, and then turn action back over to the players."
   - Updated: "You are assigned as a full gamemaster. Your role is to describe scenes, describe NPC actions, and manage combat encounters. EFFICIENCY: Batch your actions when possible - combine narrative text with dice rolls, handle multiple NPCs' turns together (e.g., roll all attacks for multiple NPCs in one response, then apply damage to all in another response), and query multiple actors' details before acting. Keep generating descriptions, actions, and dice rolls until every NPC in scene has gone, then turn action back over to the players."

5. **Update GM Assistant Role Prompt** (`unified_message_processor.py`)
   - Current: "You are assigned as a GM's assistant. Your role is to aid GM in whatever task they are currently doing, which they will usually prompt for you in their most recent message."
   - Updated: "You are assigned as a GM's assistant. Your role is to aid GM in whatever task they are currently doing, which they will usually prompt for you in their most recent message. EFFICIENCY: Batch related actions when requested - roll multiple dice formulas together, apply effects to multiple actors simultaneously, and combine chat messages logically."

6. **Update Player Role Prompt** (`unified_message_processor.py`)
   - Current: "You are assigned as a Player. Your role is to participate in story via in-character chat and actions. Describe what your character is doing and roll dice as appropriate for your actions."
   - Updated: "You are assigned as a Player. Your role is to participate in story via in-character chat and actions. EFFICIENCY: Roll multiple dice formulas in a single call when appropriate (e.g., attack roll + damage roll, or multiple saving throws together). Combine your character's description with dice rolls efficiently."

### Acceptance Criteria

- [ ] All existing tool descriptions updated with batching guidance
- [ ] All role prompts updated with efficiency instructions
- [ ] No setting-specific language (e.g., "goblins") in tool descriptions
- [ ] User's specified wording used for advance_combat_turn
- [ ] All changes are concise without examples

---

## Feature 9: Documentation

**Priority:** Medium  
**Complexity:** Low  
**Files Affected:**
- `CHANGELOG.md` (update)
- `ROADMAP.md` (update)
- `USAGE.md` (update if needed)

### Tasks

1. **Update CHANGELOG.md**
   - Create new section `## [0.3.10] - 2025-01-XX`
   - Document new features:
     - Combat encounter management
     - Turn management
     - Actor details query
     - Health management
     - Enhanced delta tracking
   - Document any breaking changes
   - Document any migration notes

2. **Update ROADMAP.md**
   - Mark Patch 0.3.10 items as complete
   - Update progress indicators
   - Note any deviations from original plan

3. **Update USAGE.md** (if needed)
   - Add examples of new tools
   - Add workflow examples for combat management

### Acceptance Criteria

- [ ] All changes documented in CHANGELOG.md
- [ ] ROADMAP.md updated with completion status
- [ ] Tool documentation complete

---

## Implementation Order

Recommended implementation sequence based on dependencies:

1. **Feature 5: Enhanced Delta Tracking** (foundational - deltas need to be ready before features use them)
2. **Feature 3: Actor Details Query** (independent feature)
3. **Feature 4: Health Management** (independent feature)
4. **Feature 1: Combat Encounter Management** (depends on delta tracking)
5. **Feature 2: Turn Management** (depends on combat management)
6. **Feature 8: Prompt Engineering Enhancements** (efficiency improvements - can be done anytime after tools defined)
7. **Feature 6: Testing Infrastructure** (validation)
8. **Feature 9: Documentation** (finalization)

---

## Testing Checklist

Before merging to main:

### Function Check Tests
- [ ] create_encounter with initiative works correctly
- [ ] create_encounter without initiative works correctly
- [ ] delete_encounter ends active combat
- [ ] advance_combat_turn advances to next combatant
- [ ] get_actor_details returns complete stat block from world
- [ ] get_actor_details returns complete stat block from compendium
- [ ] get_actor_details with search phrase returns relevant context
- [ ] update_actor_hp applies damage correctly
- [ ] update_actor_hp applies healing correctly
- [ ] TurnAdvanced delta appears after turn advance
- [ ] CombatantChanged delta appears after HP change
- [ ] CombatantChanged delta appears after status effect change

### Integration Tests
- [ ] Full combat workflow (create â†’ advance â†’ damage â†’ advance â†’ delete)
- [ ] Actor query workflow (create â†’ query â†’ damage â†’ query)
- [ ] Multi-combatant encounter with multiple turns
- [ ] Delta tracking throughout complete combat session

### Manual Testing
- [ ] Module loads without errors
- [ ] AI can start combat with multiple actors
- [ ] AI can end combat
- [ ] AI can advance turns multiple times
- [ ] AI can query actor details during combat
- [ ] AI can apply damage and healing
- [ ] Chat messages appear for damage/healing with damage types
- [ ] Combat state updates reflect all changes
- [ ] Deltas appear correctly between AI turns
- [ ] No console errors

---

## Branch Management

### Create Feature Branch
```bash
git checkout main
git pull origin main
git checkout -b feature/0.3.10-the-combatant
```

### Commit Strategy
- Separate commits per feature for easier review
- Use descriptive commit messages with prefixes:
  - `feat:` for new features
  - `refactor:` for code refactoring
  - `fix:` for bug fixes
  - `docs:` for documentation

### Merge to Main
```bash
git checkout main
git merge feature/0.3.10-the-combatant
git push origin main
```

### Tag Release
```bash
git tag v0.3.10
git push origin v0.3.10
```

---

## Release Notes

### New Features
- AI can create and delete combat encounters
- AI can advance combat turns
- AI can query detailed actor stat blocks
- AI can apply damage and healing to actors
- Enhanced delta tracking for turn advances and combatant changes

### Breaking Changes
- None

### Migration Notes
- No manual migration required for existing installations
- All features backward compatible

---

**End of Implementation Plan**
